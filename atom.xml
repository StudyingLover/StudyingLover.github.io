<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>plus studio</title>
  
  
  <link href="https://studyinglover.com/atom.xml" rel="self"/>
  
  <link href="https://studyinglover.com/"/>
  <updated>2023-10-18T10:59:56.463Z</updated>
  <id>https://studyinglover.com/</id>
  
  <author>
    <name>StudyingLover</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>xgboost使用GPU最佳实践</title>
    <link href="https://studyinglover.com/2023/10/18/xgboost%E4%BD%BF%E7%94%A8GPU%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://studyinglover.com/2023/10/18/xgboost%E4%BD%BF%E7%94%A8GPU%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2023-10-18T18:50:00.000Z</published>
    <updated>2023-10-18T10:59:56.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xgboost使用gpu最佳实践">xgboost使用GPU最佳实践</h1><p>首先更新xgboost到2.0.0 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install xgboost -U <br></code></pre></td></tr></table></figure></p><p>这里给出一个使用GPU的例子，使用的是nvidia显卡 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xgboost<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br><br><span class="hljs-comment"># 生成示例数据</span><br>np.random.seed(<span class="hljs-number">114514</span>)<br>X = np.random.randn(<span class="hljs-number">100</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 生成100个样本，每个样本有3个特征</span><br>y = stats.bernoulli.rvs(<span class="hljs-number">0.5</span>, size=<span class="hljs-number">100</span>)  <span class="hljs-comment"># 生成二分类标签，概率为0.5</span><br><br><span class="hljs-comment"># 设置参数</span><br>params = &#123;<br>    <span class="hljs-string">&quot;device&quot;</span>: <span class="hljs-string">&quot;cuda&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 创建DMatrix对象</span><br>Xy = xgboost.DMatrix(X, y)<br><br><span class="hljs-comment"># 训练模型</span><br>model = xgboost.train(params, Xy)<br><br><span class="hljs-comment"># 测试模型</span><br>test_array = np.random.randn(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>dtest = xgboost.DMatrix(test_array)<br>pred = model.predict(dtest)<br><span class="hljs-built_in">print</span>(pred)<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xgboost使用gpu最佳实践&quot;&gt;xgboost使用GPU最佳实践&lt;/h1&gt;
&lt;p&gt;首先更新xgboost到2.0.0 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="机器学习" scheme="https://studyinglover.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>马踏棋盘</title>
    <link href="https://studyinglover.com/2023/10/12/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98/"/>
    <id>https://studyinglover.com/2023/10/12/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98/</id>
    <published>2023-10-12T09:39:00.000Z</published>
    <updated>2023-10-18T10:59:56.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c代码">c代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 8</span><br><br><span class="hljs-type">int</span> move_x[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> move_y[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">is_valid_move</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> board[SIZE][SIZE])</span> &#123;<br>    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; SIZE &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; SIZE &amp;&amp; board[x][y] == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_board</span><span class="hljs-params">(<span class="hljs-type">int</span> board[SIZE][SIZE])</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SIZE; j++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2d &quot;</span>, board[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">solve_knight_tour</span><span class="hljs-params">(<span class="hljs-type">int</span> start_x, <span class="hljs-type">int</span> start_y)</span> &#123;<br>    <span class="hljs-type">int</span> board[SIZE][SIZE];<br>    <span class="hljs-type">int</span> move_count = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 初始化棋盘</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SIZE; j++) &#123;<br>            board[i][j] = <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> x = start_x;<br>    <span class="hljs-type">int</span> y = start_y;<br>    board[x][y] = move_count;<br><br>    <span class="hljs-keyword">while</span> (move_count &lt; SIZE * SIZE) &#123;<br>        <span class="hljs-type">int</span> min_deg = SIZE + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> min_index = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> next_x, next_y;<br><br>        <span class="hljs-comment">// 尝试所有可能的移动</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>            next_x = x + move_x[i];<br>            next_y = y + move_y[i];<br><br>            <span class="hljs-keyword">if</span> (is_valid_move(next_x, next_y, board)) &#123;<br>                <span class="hljs-type">int</span> deg = <span class="hljs-number">0</span>;<br><br>                <span class="hljs-comment">// 计算下一个位置的度数</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++) &#123;<br>                    <span class="hljs-type">int</span> new_x = next_x + move_x[j];<br>                    <span class="hljs-type">int</span> new_y = next_y + move_y[j];<br>                    <br>                    <span class="hljs-keyword">if</span> (is_valid_move(new_x, new_y, board)) &#123;<br>                        deg++;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// 更新最小度数和对应的索引</span><br>                <span class="hljs-keyword">if</span> (deg &lt; min_deg) &#123;<br>                    min_deg = deg;<br>                    min_index = i;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 没有找到合适的下一步移动位置</span><br>        <span class="hljs-keyword">if</span> (min_index == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 移动到下一个位置</span><br>        x += move_x[min_index];<br>        y += move_y[min_index];<br>        board[x][y] = ++move_count;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出结果</span><br>    print_board(board);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">int</span> start_x, start_y;<br><br>    <span class="hljs-comment">// printf(&quot;请输入马的初始位置（x, y）：&quot;);</span><br>    <span class="hljs-comment">// scanf(&quot;%d %d&quot;, &amp;start_x, &amp;start_y);</span><br>    <span class="hljs-comment">// start_x = 2;</span><br>    <span class="hljs-comment">// start_y = 2;</span><br>    start_x = *argv[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    start_y = *argv[<span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-comment">// printf(&quot;%d %d&quot;,start_x,start_y);</span><br><br>    solve_knight_tour(start_x, start_y);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路">思路</h3><p>这段代码使用一个while循环来控制马的移动，直到访问了棋盘上的所有格子（move_count达到SIZE * SIZE）或者无法找到合适的下一步移动位置。</p><p>在每次循环迭代中，首先初始化min_deg为SIZE + 1，min_index为-1，用来记录最小度数和对应的索引。next_x和next_y是下一个可能的移动位置的坐标。</p><p>接下来，通过一个for循环尝试所有可能的移动方式。对于每一种移动方式，计算出下一个位置的坐标next_x和next_y。然后使用is_valid_move函数判断下一个位置是否是一个有效的移动位置。如果是，进入内部的计算度数的循环。</p><p>在内部的循环中，通过move_x和move_y数组计算出下一个位置的所有可能移动方式。然后使用is_valid_move函数判断每个可能的移动位置是否有效。如果是，将度数deg加一。</p><p>完成内部的循环后，比较当前位置的度数deg和最小度数min_deg的大小。如果deg小于min_deg，则更新min_deg为deg，同时更新min_index为当前移动方式的索引i。</p><p>完成所有移动方式的尝试后，判断min_index是否仍然为-1。如果是，表示无法找到合适的下一步移动位置，即无法继续遍历所有格子。在这种情况下，跳出while循环。</p><p>如果找到了合适的下一步移动位置，将马移动到该位置。更新当前位置的坐标x和y为下一个位置的坐标next_x和next_y，然后将move_count加一，并将其赋值给当前位置的board数组。这表示马已经访问了该位置。</p><p>当循环结束后，solve_knight_tour函数就完成了马踏棋盘问题的求解，棋盘上每个格子的访问顺序已经被记录在board数组中。</p><p>请注意，该算法并不能保证一定能找到马踏棋盘问题的解，因为在某些起始位置和棋盘大小的情况下，可能无法找到完整的遍历路径。</p><h3 id="度数在这里代表什么">度数在这里代表什么?</h3><p>在这里，"度数"指的是马在当前位置的下一个可能移动位置的可访问格子数量。也可以将其理解为下一个位置的邻居节点数。</p><p>在代码中，通过计算每个可能的移动位置的度数，可以评估每个位置的可达性。度数越小表示该位置的可访问格子数量越少，即相对来说更"紧凑"。在马踏棋盘问题中，选择度数最小的位置作为下一步移动的目标，有助于保持马的移动范围广阔，增加找到解的可能性。</p><p>通过选择度数最小的位置作为下一步移动目标，可以尽量避免陷入死胡同或者无法继续遍历的局面。这种策略在一定程度上增加了找到马踏棋盘问题解的概率。</p><h3 id="马踏棋盘问题中度数最小的位置是否一定是下一步移动的最佳选择">马踏棋盘问题中，度数最小的位置是否一定是下一步移动的最佳选择？</h3><p>在马踏棋盘问题中，度数最小的位置不一定是下一步移动的最佳选择。尽管选择度数最小的位置有助于保持马的移动范围广阔，但并不能保证一定能找到问题的解。</p><p>马踏棋盘问题是一个非常复杂的组合问题，具有高度的分支因子和状态空间。在某些情况下，选择度数最小的位置可能导致陷入局部最优解，从而无法找到全局最优解，或者根本找不到解。</p><p>在某些特定的起始位置和棋盘大小下，可能存在一些特殊的路径或遍历顺序，使得度数最小的位置并不是最佳的选择。因此，仅凭度数最小来确定下一步移动的位置并不能保证找到最佳解。</p><p>为了提高找到最佳解的概率，通常需要采用更加复杂的算法和启发式策略，例如回溯算法、深度优先搜索、广度优先搜索、剪枝等。这些算法可以考虑更多的因素，如节点的可达性、棋盘上的局部结构、路径的延伸性等，以更有效地搜索解空间并找到更优的解。</p><p>因此，在解决马踏棋盘问题时，度数最小的位置可以作为一种启发式指导，但不能保证一定是下一步移动的最佳选择，需要结合其他算法和策略来综合评估和确定下一步的移动位置。</p><h2 id="python代码">python代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>lines = sys.stdin.readlines()<br><br><span class="hljs-comment"># 删除换行符并转换为整数</span><br>lines = np.array([<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, line.strip().split())) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines])<br><br><span class="hljs-comment"># lines是一个矩阵，每个点的值代表该点的访问顺序</span><br><span class="hljs-comment"># 例如，lines[0][0] = 1，代表第一个访问的点是(0, 0)</span><br><span class="hljs-comment"># lines[0][1] = 34，代表第三十四个访问的点是(0, 1)</span><br><span class="hljs-comment"># lines[1][0] = 4，代表第四个访问的点是(1, 0)</span><br><br>order_x = []<br>order_y = []<br><br>count = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> count &lt;= <span class="hljs-built_in">len</span>(lines)**<span class="hljs-number">2</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lines)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lines)):<br>            <span class="hljs-keyword">if</span> lines[i][j] == count:<br>                order_x.append(i)<br>                order_y.append(j)<br>                count += <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 绘制棋盘</span><br>plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))<br><br><span class="hljs-comment"># 绘制棋盘的格子</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lines)+<span class="hljs-number">1</span>):<br>    plt.plot([i, i], [<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(lines)], color=<span class="hljs-string">&#x27;black&#x27;</span>)<br>    plt.plot([<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(lines)], [i, i], color=<span class="hljs-string">&#x27;black&#x27;</span>)<br><br>count = <span class="hljs-number">1</span><br><span class="hljs-comment"># 绘制马的行走路线</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(order_x)-<span class="hljs-number">1</span>):<br>    plt.plot([order_x[i]+<span class="hljs-number">0.5</span>, order_x[i+<span class="hljs-number">1</span>]+<span class="hljs-number">0.5</span>], [order_y[i]+<span class="hljs-number">0.5</span>, order_y[i+<span class="hljs-number">1</span>]+<span class="hljs-number">0.5</span>], color=<span class="hljs-string">&#x27;red&#x27;</span>, )<br>    plt.scatter(order_x[i]+<span class="hljs-number">0.5</span>, order_y[i]+<span class="hljs-number">0.5</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>)<br>    <span class="hljs-comment"># 加上序号</span><br>    plt.text(order_x[i]+<span class="hljs-number">0.5</span>, order_y[i]+<span class="hljs-number">0.5</span>, <span class="hljs-built_in">str</span>(count), fontsize=<span class="hljs-number">12</span>)<br>    count += <span class="hljs-number">1</span><br>    plt.pause(<span class="hljs-number">0.01</span>)<br>    <br><span class="hljs-comment"># 绘制最后一个点</span><br>plt.scatter(order_x[-<span class="hljs-number">1</span>]+<span class="hljs-number">0.5</span>, order_y[-<span class="hljs-number">1</span>]+<span class="hljs-number">0.5</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>)<br>plt.text(order_x[-<span class="hljs-number">1</span>]+<span class="hljs-number">0.6</span>, order_y[-<span class="hljs-number">1</span>]+<span class="hljs-number">0.6</span>, <span class="hljs-built_in">str</span>(count), fontsize=<span class="hljs-number">12</span>)<br>plt.show()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c代码&quot;&gt;c代码&lt;/h2&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp</summary>
      
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
  </entry>
  
  <entry>
    <title>cloudlflare推理llama2</title>
    <link href="https://studyinglover.com/2023/10/11/cloudlflare%E6%8E%A8%E7%90%86llama2/"/>
    <id>https://studyinglover.com/2023/10/11/cloudlflare%E6%8E%A8%E7%90%86llama2/</id>
    <published>2023-10-11T15:32:00.000Z</published>
    <updated>2023-10-18T10:59:56.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cloudlflare推理llama2">cloudlflare推理llama2</h1><p>最近，cloudlfare悄悄上线了一项新功能，全球网络上的gpu加速推理，显然的，我们可以用它推理llama2,cloudflare也提供了一个库进行推理。</p><p>新建一个cloudflare,然后，代码改成下面的，就可以进行推理了 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Ai</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./vendor/@cloudflare/ai.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">request, env</span>) &#123;<br>    <span class="hljs-keyword">const</span> tasks = [];<br>    <span class="hljs-keyword">const</span> ai = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ai</span>(env.<span class="hljs-property">AI</span>);<br><br>    <span class="hljs-comment">// Get the request body</span><br>    <span class="hljs-keyword">const</span> requestBody = <span class="hljs-keyword">await</span> request.<span class="hljs-title function_">json</span>();<br><br>    <span class="hljs-comment">// messages - chat style input</span><br>    <span class="hljs-keyword">let</span> chat = &#123;<br>      <span class="hljs-attr">messages</span>: [<br>        &#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;You are a helpful, kind, honest, friendly, good at writing and never fails to answer my requests immediately and with details and precision.&#x27;</span>&#125;,<br>        &#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">content</span>: requestBody.<span class="hljs-property">prompt</span> &#125;<br>      ]<br>    &#125;;<br>    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> ai.<span class="hljs-title function_">run</span>(<span class="hljs-string">&#x27;@cf/meta/llama-2-7b-chat-int8&#x27;</span>, chat);<br>    tasks.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">inputs</span>: chat, response &#125;);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">json</span>(tasks);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>我们可以测试一下,在命令行运行下面的命令，将<code>https://example.workers.dev/</code> 换成你的网址。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -X POST https://example.workers.dev/ -d <span class="hljs-string">&#x27;&#123;&quot;prompt&quot;:&quot;Write a poem that talks about the connectivity cloud&quot;&#125;&#x27;</span> <br></code></pre></td></tr></table></figure></p><p>看到类似下面的返回值代表成功 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">[&#123;<span class="hljs-string">&quot;inputs&quot;</span>:&#123;<span class="hljs-string">&quot;messages&quot;</span>:[&#123;<span class="hljs-string">&quot;role&quot;</span>:<span class="hljs-string">&quot;system&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;You are a helpful, kind, honest, friendly, good at writing and never fails to answer my requests immediately and with details and precision.&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;role&quot;</span>:<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;Write a poem that talks about the connectivity cloud&quot;</span>&#125;]&#125;,<span class="hljs-string">&quot;response&quot;</span>:&#123;<span class="hljs-string">&quot;response&quot;</span>:<span class="hljs-string">&quot;In the realm of the digital sky,<span class="hljs-subst">\n</span>Where information flows, and data fly,<span class="hljs-subst">\n</span>There&#x27;s a place that brings us all together,<span class="hljs-subst">\n</span>A connectivity cloud, a true forever.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>It&#x27;s a space that&#x27;s vast and wide,<span class="hljs-subst">\n</span>Where thoughts and ideas collide,<span class="hljs-subst">\n</span>A hub of communication and exchange,<span class="hljs-subst">\n</span>Where the world&#x27;s voices all combine and blend.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>In this cloud of connectivity,<span class="hljs-subst">\n</span>We find our voices, our identity,<span class="hljs-subst">\n</span>A platform for sharing and growth,<span class="hljs-subst">\n</span>Where our stories are told and our dreams take flight.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>With just a click or tap of a key,<span class="hljs-subst">\n</span>We can connect with anyone, anywhere,<span class="hljs-subst">\n</span>Sharing laughter, love, and tears,<span class="hljs-subst">\n</span>In this digital embrace, we all share.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>So let us cherish this cloud of connectivity,<span class="hljs-subst">\n</span>This gift that brings us all sovereignty,<span class="hljs-subst">\n</span>For in its depths, we find our tribe,<span class="hljs-subst">\n</span>And our voices, heard, can never be denied.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>In this cloud of connectivity,<span class="hljs-subst">\n</span>We are all connected, you see,<span class="hljs-subst">\n</span>A global community, united and free,<span class="hljs-subst">\n</span>In this digital age, where we all can be&quot;</span>&#125;&#125;]<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cloudlflare推理llama2&quot;&gt;cloudlflare推理llama2&lt;/h1&gt;
&lt;p&gt;最近，cloudlfare悄悄上线了一项新功能，全球网络上的gpu加速推理，显然的，我们可以用它推理llama2,cloudflare也提供了一个库进行推理。&lt;/p&gt;</summary>
      
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
  </entry>
  
  <entry>
    <title>docker搭建elasticsearch并使用python连接</title>
    <link href="https://studyinglover.com/2023/10/09/docker%E6%90%AD%E5%BB%BAelasticsearch%E5%B9%B6%E4%BD%BF%E7%94%A8python%E8%BF%9E%E6%8E%A5/"/>
    <id>https://studyinglover.com/2023/10/09/docker%E6%90%AD%E5%BB%BAelasticsearch%E5%B9%B6%E4%BD%BF%E7%94%A8python%E8%BF%9E%E6%8E%A5/</id>
    <published>2023-10-09T21:48:00.000Z</published>
    <updated>2023-10-18T10:59:56.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker搭建elasticsearch并使用python连接">docker搭建elasticsearch并使用python连接</h1><h2 id="搭建">搭建</h2><p>创建一个docker网络 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create elastic<br></code></pre></td></tr></table></figure></p><p>然后拉elasticsearch 的docker 容器 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull docker.elastic.co/elasticsearch/elasticsearch:8.10.2<br></code></pre></td></tr></table></figure></p><p>运行容器 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name es01 --net elastic -p 9200:9200 -it -m 1GB docker.elastic.co/elasticsearch/elasticsearch:8.10.2<br></code></pre></td></tr></table></figure></p><p>如果遇到报错<code>Elasticsearch exited unexpectedly, with exit code 78</code> ，在终端运行<code>sudo sysctl -w vm.max_map_count=262144</code>然后删掉刚才的镜像，重新运行容器。(这个设置重启后会失效，可以在<code>/etc/sysctl.conf</code>以设置使其永久有效。)</p><p>成功运行终端会弹出很多信息，然后最后会给出密码等，如下</p><p><img src="https://cdn.studyinglover.com/pic/2023/10/415a20e102e85b136bc5831f789a10af.png" /></p><p>记得保存密码，可以将密码加到环境变量里<code>export ELASTIC_PASSWORD="your_password"</code>，他只会弹出一次。如果忘了也可以重置密码 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it es01 /usr/share/elasticsearch/bin/elasticsearch-reset-password -u elastic<br>docker <span class="hljs-built_in">exec</span> -it es01 /usr/share/elasticsearch/bin/elasticsearch-create-enrollment-token -s kibana<br></code></pre></td></tr></table></figure></p><h2 id="验证是否正常运行">验证是否正常运行</h2><p>把证书从容器中复制一份 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> es01:/usr/share/elasticsearch/config/certs/http_ca.crt .<br></code></pre></td></tr></table></figure></p><p>然后运行命令查看restful api是否正常运行 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">curl <span class="hljs-attr">--cacert</span> http_ca<span class="hljs-selector-class">.crt</span> -u elastic:<span class="hljs-variable">$ELASTIC_PASSWORD</span> https:<span class="hljs-comment">//localhost:9200</span><br></code></pre></td></tr></table></figure> 如果看到类似下图的信息就成功了 <img src="https://cdn.studyinglover.com/pic/2023/10/fa51ee2db2826abe7649dc0b88865beb.png" alt="image.png" /></p><h2 id="python连接">python连接</h2><p>运行下面的代码,password改成你自己的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> elasticsearch <span class="hljs-keyword">import</span> AsyncElasticsearch<br><span class="hljs-keyword">import</span> ssl<br><span class="hljs-keyword">import</span> asyncio<br><br>ssl_context = ssl.create_default_context(cafile=<span class="hljs-string">&#x27;info/http_ca.crt&#x27;</span>)<br>es = AsyncElasticsearch(<br>    [<span class="hljs-string">&#x27;https://localhost:9200&#x27;</span>],<br>    http_auth=(<span class="hljs-string">&#x27;elastic&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>),<br>    scheme=<span class="hljs-string">&quot;https&quot;</span>,<br>    ssl_context=ssl_context<br>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    info = <span class="hljs-keyword">await</span> es.info()<br>    <span class="hljs-built_in">print</span>(info)<br>    <span class="hljs-keyword">await</span> es.close()<br><br><span class="hljs-comment"># 运行主函数</span><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>看到类似下面的输出代表运行成功 <img src="https://cdn.studyinglover.com/pic/2023/10/2c951211fd5820abebf0395b779f35bd.png" alt="image.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker搭建elasticsearch并使用python连接&quot;&gt;docker搭建elasticsearch并使用python连接&lt;/h1&gt;
&lt;h2 id=&quot;搭建&quot;&gt;搭建&lt;/h2&gt;
&lt;p&gt;创建一个docker网络 &lt;figure class=&quot;highlight</summary>
      
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
  </entry>
  
  <entry>
    <title>FreeU-文字生成图片的免费午餐笔记</title>
    <link href="https://studyinglover.com/2023/10/01/FreeU-%E6%96%87%E5%AD%97%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E7%9A%84%E5%85%8D%E8%B4%B9%E5%8D%88%E9%A4%90/"/>
    <id>https://studyinglover.com/2023/10/01/FreeU-%E6%96%87%E5%AD%97%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E7%9A%84%E5%85%8D%E8%B4%B9%E5%8D%88%E9%A4%90/</id>
    <published>2023-10-01T15:05:00.000Z</published>
    <updated>2023-10-18T10:59:56.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="freeu-文字生成图片的免费午餐">FreeU-文字生成图片的免费午餐</h1><p>项目地址<a href="https://chenyangsi.top/FreeU/">主页</a></p><p>作者在这篇论文引入了一种对UNet的改进方式，不需要重新训练和微调。</p><figure><img src="https://cdn.studyinglover.com/pic/2023/10/c48e2f490270ef836b26f6d7ed8d7f0e.png" alt="" /><figcaption>image.png</figcaption></figure><p>在UNet中存在两种连接，一种是上一层网络传递来的基础连接，主要贡献去噪能力。一种是跳线连接，主要贡献高频细节。UNet会将这两部分的特征contat之后作为下一层输入。作者的方法就是对这两部分做调整来提升图像质量。 <img src="https://cdn.studyinglover.com/pic/2023/10/483c5afa7533a2e1dcaf2cf0273c6677.png" alt="image.png" /></p><p>从技术上讲，对于 U-Net 解码器的第 <span class="math inline">\(l\)</span> 个块，<span class="math inline">\(\boldsymbol{x}_{l}\)</span> 表示前一个块主主干的主干特征图，让 <span class="math inline">\(h_l\)</span> 表示通过相应跳过连接传播的特征图。为了调整这些特征图，作者引入了两个标量因子：<span class="math inline">\(x_l\)</span> 对应的主干特征比例因子 <span class="math inline">\(b_l\)</span> 和 <span class="math inline">\(h_l\)</span> 的跳线特征对应的比例因子 sl。具体来说，因子 <span class="math inline">\(b_l\)</span> 旨在放大主干特征图 <span class="math inline">\(x_l\)</span>，而因子 <span class="math inline">\(s_l\)</span> 旨在衰减跳过特征图 <span class="math inline">\(h_l\)</span>。对于主干特征，在实验调查中，作者发现通过与<span class="math inline">\(b_l\)</span>相乘不加区别地放大<span class="math inline">\(x_l\)</span>的所有通道，在生成的合成图像中产生过度平滑的纹理。原因是增强的U-Net在去噪时损害了图像的高频细节，所以将缩放操作限制在<span class="math inline">\(x_l\)</span>的一半通道，如下所示:<span class="math display">\[\boldsymbol{x}_{l,i}^{^{\prime}}=\begin{cases}b_l\cdot\boldsymbol{x}_{l,i},&amp;\mathrm{~if~}i&lt;C/2\\\boldsymbol{x}_{l,i},&amp;\mathrm{~otherwise}&amp;\end{cases}\]</span></p><p>其中<span class="math inline">\(\boldsymbol{x}_{l,i}\)</span> 是第<span class="math inline">\(i\)</span> 层的第<span class="math inline">\(l\)</span>个特征图，<span class="math inline">\(C\)</span>是通道数。这个方法不仅增强了主干的去噪能力，而且还避免了全局应用缩放的不良结果，从而在降噪和纹理保存之间取得更细微的平衡。</p><p>为了进一步缓解由于增强去噪而导致的过度平滑纹理问题，FreeU进一步在傅里叶域中使用光谱调制来选择性地减少跳过特征的低频分量。在数学上，此操作执行如下<span class="math display">\[\begin{aligned}\mathcal{F}(\boldsymbol{h}_{l,i})&amp; =\operatorname{FFT}(\boldsymbol{h}_{l,i})  \\\mathcal{F}^{\prime}(\boldsymbol{h}_{l,i})&amp; =\mathcal{F}(\boldsymbol{h}_{l,i})\odot\boldsymbol{\alpha}_{l,i}  \\\boldsymbol{h}_{l,i}^{\prime}&amp; =\mathrm{IFFT}(\mathcal{F}^{\prime}(\boldsymbol{h}_{l,i})) \end{aligned}\]</span></p><p><span class="math inline">\(\mathrm{FFT}(\cdot)\)</span> 和 <span class="math inline">\(\operatorname{IFFT}(\cdot)\)</span> 是傅里叶变换和反傅里叶变换，<span class="math inline">\(\odot\)</span> 是逐元素乘法。</p><p><span class="math inline">\(\boldsymbol{\alpha}_{l,i}\)</span>是一个傅里叶掩码，用于设定<span class="math inline">\(s_l\)</span>的大小，<span class="math inline">\(R\)</span>是半径，<span class="math inline">\(r_\mathrm{thresh}\)</span> 是频率阈值 <span class="math display">\[\boldsymbol{\alpha}_{l,i}(r)=\begin{cases}s_l&amp;\mathrm{~if~}r&lt;r_\mathrm{thresh},\\1&amp;\text{ otherwise.}&amp;\end{cases}\]</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;freeu-文字生成图片的免费午餐&quot;&gt;FreeU-文字生成图片的免费午餐&lt;/h1&gt;
&lt;p&gt;项目地址&lt;a href=&quot;https://chenyangsi.top/FreeU/&quot;&gt;主页&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者在这篇论文引入了一种对UNet的改进方式，不需要重新训</summary>
      
    
    
    
    <category term="笔记" scheme="https://studyinglover.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="文字生成图片" scheme="https://studyinglover.com/tags/%E6%96%87%E5%AD%97%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>使用xgboost的c接口推理模型</title>
    <link href="https://studyinglover.com/2023/09/10/%E4%BD%BF%E7%94%A8xgboost%E7%9A%84c%E6%8E%A5%E5%8F%A3%E6%8E%A8%E7%90%86%E6%A8%A1%E5%9E%8B/"/>
    <id>https://studyinglover.com/2023/09/10/%E4%BD%BF%E7%94%A8xgboost%E7%9A%84c%E6%8E%A5%E5%8F%A3%E6%8E%A8%E7%90%86%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-09-10T21:10:00.000Z</published>
    <updated>2023-10-18T10:59:56.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用xgboost的c接口推理模型">使用xgboost的c接口推理模型</h1><p>官方<a href="https://xgboost.readthedocs.io/en/stable/tutorials/c_api_tutorial.html">c api tutorial</a>和<a href="https://xgboost.readthedocs.io/en/stable/c.html">文档</a>，非常恶心的一点是，tutorial和文档问题很多。</p><p>也参考了不少开源项目，主要有<a href="https://github.com/R-Stalker/xgboost-c-cplusplus">xgboost-c-cplusplus</a>,<a href="https://github.com/EmbolismSoil/xgboostpp">xgboostpp</a>.</p><p>首先导入头文件<code>#include "xgboost/c_api.h"</code> ，接下来xgboost的绝大多数接口都包含在了这个头文件中。</p><p>然后我们需要一个宏，来用它获取xgboost函数使用的情况.在每次调用xgboost函数时都应该调用这个宏。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> safe_xgboost(call) &#123;  \</span><br><span class="hljs-meta">  int err = (call); \</span><br><span class="hljs-meta">  <span class="hljs-keyword">if</span> (err != 0) &#123; \</span><br><span class="hljs-meta">    fprintf(stderr, <span class="hljs-string">&quot;%s:%d: error in %s: %s\n&quot;</span>, __FILE__, __LINE__, #call, XGBGetLastError());  \</span><br><span class="hljs-meta">    exit(1); \</span><br><span class="hljs-meta">  &#125; \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure></p><p>我们使用的模型文件为<code>xgboost_model.bin</code> ,训练数据的输入是 <strong>11</strong> 个元素。</p><p>首先我们声明一个boost模型的句柄<code>BoosterHandle booster;</code> 接着用<code>XGBoosterCreate</code> 函数创建一个模型 。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">BoosterHandle booster;<br>safe_xgboost(XGBoosterCreate(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;booster));<br></code></pre></td></tr></table></figure></p><p>设置一个字符串作为模型路径<code>const char *model_path = "../xgboost_model.bin";</code>(<code>../</code>是因为编译出来的可执行文件在build目录下) ， 通过句柄使用<code>XGBoosterLoadModel</code>函数加载模型。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *model_path = <span class="hljs-string">&quot;../xgboost_model.bin&quot;</span>;<br>XGBoosterLoadModel(booster, model_path)<br></code></pre></td></tr></table></figure></p><p>设置一组数据作为推理测试，这里我选的数据标签是1.接着将输入数据转为xgboost的DMatrix格式。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> a[<span class="hljs-number">11</span>]= &#123;<span class="hljs-number">14.0</span>,<span class="hljs-number">2.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">12.0</span>,<span class="hljs-number">19010.0</span>,<span class="hljs-number">120.0</span>,<span class="hljs-number">14.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>&#125;;<br>DMatrixHandle h_test;<br>safe_xgboost(XGDMatrixCreateFromMat(a, <span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">-1</span>, &amp;h_test));<br></code></pre></td></tr></table></figure></p><p>下面就可以进行模型推理了，<code>out_len</code> 代表输出的长度(实际上是一个整型变量)，<code>f</code>的模型推理的结果。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">bst_ulong out_len;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> *f;<br>safe_xgboost(XGBoosterPredict(booster, h_test, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;out_len, &amp;f));<br></code></pre></td></tr></table></figure></p><p>我们可以打印输出查看结果 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of the variable: %f\n&quot;</span>, f[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure></p><p>最后记得释放内存 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">XGDMatrixFree(h_test);<br>XGBoosterFree(booster);<br></code></pre></td></tr></table></figure></p><p>完整的代码 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xgboost/c_api.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> safe_xgboost(call) &#123;  \</span><br><span class="hljs-meta">  int err = (call); \</span><br><span class="hljs-meta">  <span class="hljs-keyword">if</span> (err != 0) &#123; \</span><br><span class="hljs-meta">    fprintf(stderr, <span class="hljs-string">&quot;%s:%d: error in %s: %s\n&quot;</span>, __FILE__, __LINE__, #call, XGBGetLastError());  \</span><br><span class="hljs-meta">    exit(1); \</span><br><span class="hljs-meta">  &#125; \</span><br><span class="hljs-meta">&#125;</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *model_path = <span class="hljs-string">&quot;../xgboost_model.bin&quot;</span>;<br><br>    <span class="hljs-comment">// create booster handle first</span><br>    BoosterHandle booster;<br>    safe_xgboost(XGBoosterCreate(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;booster));<br>    <span class="hljs-comment">// load model</span><br>    safe_xgboost(XGBoosterLoadModel(booster, model_path));<br><br>    <span class="hljs-comment">//generate random data of a a[11],every nuber from 0 to 2</span><br>    <span class="hljs-comment">// float a[11]= &#123;1.0,12.0,1.0,1.0,16134.0,20600.0,0.0,1.0,0.0,0.0,0.0&#125;; // label: 0.0</span><br>    <span class="hljs-type">float</span> a[<span class="hljs-number">11</span>]= &#123;<span class="hljs-number">14.0</span>,<span class="hljs-number">2.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">12.0</span>,<span class="hljs-number">19010.0</span>,<span class="hljs-number">120.0</span>,<span class="hljs-number">14.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>&#125;; <span class="hljs-comment">// label: 1.0</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">11</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f, &quot;</span>, a[i]);<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// convert to DMatrix</span><br>    DMatrixHandle h_test;<br>    safe_xgboost(XGDMatrixCreateFromMat(a, <span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">-1</span>, &amp;h_test));<br>    <span class="hljs-comment">// predict</span><br>    bst_ulong out_len;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> *f;<br>    safe_xgboost(XGBoosterPredict(booster, h_test, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;out_len, &amp;f));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of the variable: %f\n&quot;</span>, f[<span class="hljs-number">0</span>]);<br><br>    XGDMatrixFree(h_test);<br>    XGBoosterFree(booster);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>使用cmake编译 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CMakeLists.txt">cmake_minimum_required(VERSION 3.18)<br>project(project_name LANGUAGES C CXX VERSION 0.1)<br>set(xgboost_DIR &quot;/usr/include/xgboost&quot;)<br><br>include_directories($&#123;xgboost_DIR&#125;)<br>link_directories($&#123;xgboost_DIR&#125;)<br><br>add_executable(project_name test.c)<br>target_link_libraries(project_name xgboost)<br></code></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> ./build<br>cmake ..<br>make .<br>./project_name<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用xgboost的c接口推理模型&quot;&gt;使用xgboost的c接口推理模型&lt;/h1&gt;
&lt;p&gt;官方&lt;a href=&quot;https://xgboost.readthedocs.io/en/stable/tutorials/c_api_tutorial.html&quot;&gt;c ap</summary>
      
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="机器学习" scheme="https://studyinglover.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Archlinux使用CMake调用xgboost的c接口</title>
    <link href="https://studyinglover.com/2023/09/09/Archlinux%E4%BD%BF%E7%94%A8CMake%E8%B0%83%E7%94%A8xgboost%E7%9A%84c%E6%8E%A5%E5%8F%A3/"/>
    <id>https://studyinglover.com/2023/09/09/Archlinux%E4%BD%BF%E7%94%A8CMake%E8%B0%83%E7%94%A8xgboost%E7%9A%84c%E6%8E%A5%E5%8F%A3/</id>
    <published>2023-09-09T20:53:00.000Z</published>
    <updated>2023-10-18T10:59:56.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="archlinux使用cmake调用xgboost的c接口">Archlinux使用CMake调用xgboost的c接口</h1><p>平台Archlinux,直接<code>yay</code> 安装xgboost,相关的.h文件会被直接安装到<code>/usr/include/xgboost</code> 路径下，所有在<code>CMakeLists.txt</code> 设置<code>include_directories</code> 到该路径下即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CMakeLists.txt">cmake_minimum_required(VERSION 3.18)<br>project(project_name LANGUAGES C CXX VERSION 0.1)<br>set(xgboost_DIR &quot;/usr/include/xgboost&quot;)<br><br>include_directories($&#123;xgboost_DIR&#125;)<br>link_directories($&#123;xgboost_DIR&#125;)<br><br>add_executable(project_name test.c)<br>target_link_libraries(project_name xgboost)<br></code></pre></td></tr></table></figure><p>在c文件中直接调用头文件 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xgboost/c_api.h&quot;</span></span><br></code></pre></td></tr></table></figure></p><p>编译使用cmake <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> ./build<br>cmake ..<br>make <br>./project_name<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;archlinux使用cmake调用xgboost的c接口&quot;&gt;Archlinux使用CMake调用xgboost的c接口&lt;/h1&gt;
&lt;p&gt;平台Archlinux,直接&lt;code&gt;yay&lt;/code&gt; 安装xgboost,相关的.h文件会被直接安装到&lt;code&gt;/u</summary>
      
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="机器学习" scheme="https://studyinglover.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>m2cgen生成机器学习c语言推理代码</title>
    <link href="https://studyinglover.com/2023/09/07/m2cgen%E7%94%9F%E6%88%90c%E8%AF%AD%E8%A8%80%E6%8E%A8%E7%90%86%E4%BB%A3%E7%A0%81/"/>
    <id>https://studyinglover.com/2023/09/07/m2cgen%E7%94%9F%E6%88%90c%E8%AF%AD%E8%A8%80%E6%8E%A8%E7%90%86%E4%BB%A3%E7%A0%81/</id>
    <published>2023-09-07T15:48:00.000Z</published>
    <updated>2023-10-18T10:59:56.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="m2cgen生成机器学习c语言推理代码">m2cgen生成机器学习c语言推理代码</h1><p>众所周知，cubemx是一个用于生成嵌入式的代码的好东西虽然我没用过。它的原理是将原本的矩阵运算和tensor变成了一个c的数组，同时会对代码进行优化，然后进行运算。</p><p>但是如果我们需要在其他平台上使用其他语言就很尴尬了，因为我们没有cubemx来做生成和优化。感谢蓬勃发展的社区，<a href="https://github.com/BayesWitnesses/m2cgen">m2cgen</a>解决了我们的问题。</p><p>使用起来非常简单，我们使用xgboost举例，先训练一个xgboost模型 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_diabetes<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> linear_model<br><br>X, y = load_diabetes(return_X_y=<span class="hljs-literal">True</span>)<br><br>estimator = linear_model.LinearRegression()<br>estimator.fit(X, y)<br></code></pre></td></tr></table></figure></p><p>然后导出c代码 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> m2cgen <span class="hljs-keyword">as</span> m2c<br>code = m2c.export_to_c(estimator)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span> (<span class="hljs-string">&#x27;model.c&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>   f.write(code)<br></code></pre></td></tr></table></figure></p><p>我们可以看到导出的代码已经是纯c语言的代码了，是以一个函数保存的 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">score</span><span class="hljs-params">(<span class="hljs-type">double</span> * input)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">152.13348416289597</span> + input[<span class="hljs-number">0</span>] * <span class="hljs-number">-10.009866299810508</span> + input[<span class="hljs-number">1</span>] * <span class="hljs-number">-239.81564367242302</span> + input[<span class="hljs-number">2</span>] * <span class="hljs-number">519.845920054461</span> + input[<span class="hljs-number">3</span>] * <span class="hljs-number">324.38464550232334</span> + input[<span class="hljs-number">4</span>] * <span class="hljs-number">-792.1756385522302</span> + input[<span class="hljs-number">5</span>] * <span class="hljs-number">476.73902100525737</span> + input[<span class="hljs-number">6</span>] * <span class="hljs-number">101.04326793803405</span> + input[<span class="hljs-number">7</span>] * <span class="hljs-number">177.06323767134606</span> + input[<span class="hljs-number">8</span>] * <span class="hljs-number">751.2736995571034</span> + input[<span class="hljs-number">9</span>] * <span class="hljs-number">67.62669218370456</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>如果你遇到了这样的一个错误 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">base_score = -math.log(1.0 / self._base_score - 1.0)<br>                           ~~~~^~~~~~~~~~~~~~~~~~<br>TypeError: unsupported operand <span class="hljs-built_in">type</span>(s) <span class="hljs-keyword">for</span> /: <span class="hljs-string">&#x27;float&#x27;</span> and <span class="hljs-string">&#x27;NoneType&#x27;</span><br></code></pre></td></tr></table></figure> 这是由于xgboost模型字段发生变化导致的，在<code>m2c.export_to_c</code>之前加入<code>model.base_score = 0</code> 就行 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> m2cgen <span class="hljs-keyword">as</span> m2c<br>model.base_score = <span class="hljs-number">0</span><br>code = m2c.export_to_c(estimator)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span> (<span class="hljs-string">&#x27;model.c&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>   f.write(code)<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;m2cgen生成机器学习c语言推理代码&quot;&gt;m2cgen生成机器学习c语言推理代码&lt;/h1&gt;
&lt;p&gt;众所周知，cubemx是一个用于生成嵌入式的代码的好东西虽然我没用过。它的原理是将原本的矩阵运算和tensor变成了一个c的数组，同时会对代码进行优化，然后进行运算。</summary>
      
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="机器学习" scheme="https://studyinglover.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>xgboost模型序列化存储并推理</title>
    <link href="https://studyinglover.com/2023/09/07/xgboost%E6%A8%A1%E5%9E%8B%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%98%E5%82%A8%E5%B9%B6%E6%8E%A8%E7%90%86/"/>
    <id>https://studyinglover.com/2023/09/07/xgboost%E6%A8%A1%E5%9E%8B%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%98%E5%82%A8%E5%B9%B6%E6%8E%A8%E7%90%86/</id>
    <published>2023-09-07T15:03:00.000Z</published>
    <updated>2023-10-18T10:59:56.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xgboost模型序列化存储并推理">xgboost模型序列化存储并推理</h1><p>参考了博客 https://github.com/apachecn/ml-mastery-zh/blob/master/docs/xgboost/save-gradient-boosting-models-xgboost-python.md ，但是修改了一些过时的部分。</p><p>我们在 <a href="https://archive.ics.uci.edu/ml/datasets/Pima+Indians+Diabetes">Pima 印第安人糖尿病数据集</a> 上训练xgboost模型，训练数据集在<a href="https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv">GitHub</a> 下载 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv<br></code></pre></td></tr></table></figure></p><h2 id="pickle">Pickle</h2><p>Pickle是一个python序列化的标准方法。</p><p>先训练一个模型,然后将模型按照Pickle的形式存储，接下来读取模型并进行推理 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> loadtxt<br><span class="hljs-keyword">import</span> xgboost<br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> model_selection<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> model_selection <span class="hljs-keyword">as</span> cross_validation<br><span class="hljs-comment"># load data</span><br>dataset = loadtxt(<span class="hljs-string">&#x27;pima-indians-diabetes.data.csv&#x27;</span>, delimiter=<span class="hljs-string">&quot;,&quot;</span>)<br><span class="hljs-comment"># split data into X and y</span><br>X = dataset[:,<span class="hljs-number">0</span>:<span class="hljs-number">8</span>]<br>Y = dataset[:,<span class="hljs-number">8</span>]<br><span class="hljs-comment"># split data into train and test sets</span><br>seed = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>test_size = <span class="hljs-number">0.33</span><br><br>X_train, X_test, y_train, y_test = cross_validation.train_test_split(X, Y, test_size=test_size, random_state=seed)<br><span class="hljs-comment"># fit model no training data</span><br>model = xgboost.XGBClassifier()<br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># save model to file</span><br>pickle.dump(model, <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;pima.pickle.dat&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>))<br><br></code></pre></td></tr></table></figure></p><p>读取模型并推理 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># load model from file</span><br>loaded_model = pickle.load(<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;pima.pickle.dat&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>))<br><span class="hljs-comment"># train model again</span><br>loaded_model.fit(X_train, y_train)<br><br><span class="hljs-comment"># make predictions for test data</span><br>y_pred = loaded_model.predict(X_test)<br>predictions = [<span class="hljs-built_in">round</span>(value) <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> y_pred]<br><span class="hljs-comment"># evaluate predictions</span><br>accuracy = accuracy_score(y_test, predictions)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy: %.2f%%&quot;</span> % (accuracy * <span class="hljs-number">100.0</span>))<br></code></pre></td></tr></table></figure></p><h2 id="joblib">joblib</h2><p>Joblib 是一组在 Python 中提供<strong>轻量级流水线</strong>的工具，<strong>joblib 在大型 numpy 数组上通常要快得多</strong></p><p>用法实际上和pickle基本相同。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Train XGBoost model, save to file using joblib, load and make predictions</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> loadtxt<br><span class="hljs-keyword">import</span> xgboost<br><span class="hljs-keyword">import</span> joblib<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> model_selection<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> model_selection <span class="hljs-keyword">as</span> cross_validation<br><span class="hljs-comment"># load data</span><br>dataset = loadtxt(<span class="hljs-string">&#x27;pima-indians-diabetes.data.csv&#x27;</span>, delimiter=<span class="hljs-string">&quot;,&quot;</span>)<br><span class="hljs-comment"># split data into X and y</span><br>X = dataset[:,<span class="hljs-number">0</span>:<span class="hljs-number">8</span>]<br>Y = dataset[:,<span class="hljs-number">8</span>]<br><span class="hljs-comment"># split data into train and test sets</span><br>seed = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>test_size = <span class="hljs-number">0.33</span><br>X_train, X_test, y_train, y_test = cross_validation.train_test_split(X, Y, test_size=test_size, random_state=seed)<br><span class="hljs-comment"># fit model no training data</span><br>model = xgboost.XGBClassifier()<br>model.fit(X_train, y_train)<br><span class="hljs-comment"># save model to file</span><br>joblib.dump(model, <span class="hljs-string">&quot;pima.joblib.dat&quot;</span>)<br><br></code></pre></td></tr></table></figure></p><p>读取模型并推理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># load model from file</span><br>loaded_model = joblib.load(<span class="hljs-string">&quot;pima.joblib.dat&quot;</span>)<br><span class="hljs-comment"># make predictions for test data</span><br>y_pred = loaded_model.predict(X_test)<br>predictions = [<span class="hljs-built_in">round</span>(value) <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> y_pred]<br><span class="hljs-comment"># evaluate predictions</span><br>accuracy = accuracy_score(y_test, predictions)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy: %.2f%%&quot;</span> % (accuracy * <span class="hljs-number">100.0</span>))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xgboost模型序列化存储并推理&quot;&gt;xgboost模型序列化存储并推理&lt;/h1&gt;
&lt;p&gt;参考了博客 https://github.com/apachecn/ml-mastery-zh/blob/master/docs/xgboost/save-gradient-</summary>
      
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="机器学习" scheme="https://studyinglover.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>speculative-sampling笔记</title>
    <link href="https://studyinglover.com/2023/09/05/speculative-sampling%E7%AC%94%E8%AE%B0/"/>
    <id>https://studyinglover.com/2023/09/05/speculative-sampling%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-05T19:40:00.000Z</published>
    <updated>2023-10-18T10:59:56.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="speculative-sampling笔记">speculative-sampling笔记</h1><p>speculative-sampling,投机采样是一种加速llm推理的方法。</p><p>论文<a href="https://arxiv.org/abs/2302.01318">arxiv</a> ,参考博客<a href="https://jaykmody.com/blog/speculative-sampling/">jaykmody.com</a></p><p>这个方法需要用到两个模型，一个小模型，称为 draft model，一个大模型，称为target model。</p><p>speculative-sampling使用了一种直觉，对于一些序列下一个token预测是i很明显的，小模型也可以完成。因此，如果draft model和target model在给定的很明显的序列上的分布之间存在很强的一致性，那么就允许targrt model被调用时一次输出多个token</p><p><img src="https://cdn.studyinglover.com/pic/2023/09/a74b5ced4e8f8945acc8cf6b4fbbdfb7.png" alt="image.png" /> 自回归采样，就是说给一个序列模型预测下一个token。</p><p><img src="https://cdn.studyinglover.com/pic/2023/09/5867fc09bb99e8709725e0813d4ad7cf.png" alt="image.png" /> 对于大模型来说，主要是三个部分拖慢了推理速度，线性层，注意力机制和通信。</p><p>拒绝采样的公式被修改为<span class="math display">\[\min\left(1,\frac{q(\tilde{x}_{n+1}|x_1,\ldots,x_n)}{p(\tilde{x}_{n+1}|x_1,\ldots,x_n)}\right)\]</span> 给定一个序列<span class="math inline">\(x_0,\ldots,x_t\)</span> 和一个<span class="math inline">\(K\)</span> ,用draft model先采样<span class="math inline">\(\tilde{x}_t\sim p(x|,x_1,\ldots,x_n,\tilde{x}_1,\ldots,\tilde{x}_{t-1})\)</span> ，循环<span class="math inline">\(K\)</span>词</p><p>然后并行计算<span class="math inline">\(q(x|,x_1,\ldots,x_n),~q(x|,x_1,\ldots,x_n,\tilde{x}_1),~\ldots,~q(x|,x_1,\ldots,x_n,\tilde{x}_1,\ldots,\tilde{x}_K)\)</span></p><p>采样一个<span class="math inline">\(r\sim U[0,1]\)</span> ,如果<span class="math inline">\(r&lt;\min\left(1,\frac{q(x|x_1,...,x_{n+t-1})}{p(x|x_1,...,x_{n+t-1})}\right)\)</span> 就把<span class="math inline">\({\tilde{x}_t}\)</span> 拼到序列<span class="math inline">\(x_{n+t-1}\)</span> 后面，这里的<span class="math inline">\(n\)</span> 是序列长度。</p><p>如果<span class="math inline">\(\tilde{x}_{n+1}\)</span> 被拒绝了，也就是说<span class="math inline">\(r&gt;\min\left(1,\frac{q(x|x_1,...,x_{n+t-1})}{p(x|x_1,...,x_{n+t-1})}\right)\)</span>,那么就直接按照<span class="math inline">\(x_{n+1}\sim(q(x|x_1,\ldots,x_n)-p(x|x_1,\ldots,x_n))_+\)</span>采样一个<span class="math inline">\(x_{n+1}\)</span></p><p><span class="math inline">\((.)_{+}\)</span> 被定义为<span class="math display">\[(f(x))_+=\frac{\max(0,f(x))}{\sum_x\max(0,f(x))}\]</span> 如果所有的token都被接受了，那就再采样一个拼到序列后面，然后结束。</p><p>使用标准采样方法，如核、top-k 采样和调整温度，可以在应用这种拒绝采样方案之前相应地修改概率。作者观察到整体接受率对使用的确切参数具有鲁棒性。</p><p>因为speculative-sampling没有改变transformer的结构，所以<strong>可以和其他方法结合使用</strong> ,例如量化，multi-query attention。</p><p>在选择draft model方面，可以简单地使用较小版本的目标语言模型作为草稿并获得较高的接受率。从工程和工作流程的角度来看，这也很方便，因为应该首先存在对此类模型的稳健工具来训练目标模型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;speculative-sampling笔记&quot;&gt;speculative-sampling笔记&lt;/h1&gt;
&lt;p&gt;speculative-sampling,投机采样是一种加速llm推理的方法。&lt;/p&gt;
&lt;p&gt;论文&lt;a href=&quot;https://arxiv.org/a</summary>
      
    
    
    
    <category term="笔记" scheme="https://studyinglover.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="自然语言处理" scheme="https://studyinglover.com/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>prompt2model笔记</title>
    <link href="https://studyinglover.com/2023/09/05/prompt2model%E7%AC%94%E8%AE%B0/"/>
    <id>https://studyinglover.com/2023/09/05/prompt2model%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-05T09:15:00.000Z</published>
    <updated>2023-10-18T10:59:56.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="prompt2model笔记">prompt2model笔记</h1><p>prompt2model是一个通过提示自动生成语言模型的方法</p><p>项目地址<a href="https://github.com/neulab/prompt2model">GitHub</a></p><figure><img src="https://cdn.studyinglover.com/pic/2023/09/b125b68b936c4cce09d451a5f790cb35.png" alt="" /><figcaption>image.png</figcaption></figure><p>模型分为Prompt Parser，Dataset Retriever，Dataset Generator，Model Retriever几个部分</p><h2 id="prompt-parser">Prompt Parser</h2><figure><img src="https://cdn.studyinglover.com/pic/2023/09/b8ddca1c0daa867307144f0a5546230a.png" alt="" /><figcaption>image.png</figcaption></figure><p>作者使用具有上下文学习的 LLM 来分割用户提示，在实验中使用 OpenAI gpt-3.5-turbo-0613。如果提供的指令被识别为英语以外的语言，就使用 DeepL API.2 将其转换为英语</p><h2 id="dataset-retriever">Dataset Retriever</h2><figure><img src="https://cdn.studyinglover.com/pic/2023/09/8acdf0823c2fb3757b694f71e982a0ce.png" alt="" /><figcaption>image.png</figcaption></figure><p>给定一个提示，首先尝试发现现有的手动注释的数据，可以支持用户的任务描述。数据集检索器有几个设计决策：</p><ol type="1"><li>搜索哪些数据集。</li><li>如何索引数据集以供搜索。</li><li>3.用户任务需要哪些数据集列，应该忽略哪些列。 作者选用了 Viswanathan et al. (2023) 的方案，称为DataFinder</li></ol><p>作者利用 DataFinder 训练的双编码器检索器对最相关的数据集进行排名。一旦确定了相关数据集，下一步是确定数据集的哪些列对应于用户指定的输入和期望输出。由于自动为任何数据集诱导正确的模式可能具有挑战性，所以作者采用了 human-inthe-loop 中的方法。将前 k 个数据集（默认情况下 k = 25）呈现给用户，并允许用户要么选择最相关的数据集，要么声明没有一个非常适合他们的任务。然后，要求用户从数据集的模式中识别输入和输出的适当列。</p><h2 id="dataset-generator">Dataset Generator</h2><p><img src="https://cdn.studyinglover.com/pic/2023/09/622f2321a6504a87d67b8866a2c5c0b5.png" alt="image.png" /> 作者使用自动提示工程来生成不同的数据集，使用退火算法对生成的数据集进行排名。自一致性过滤来防止llm生成的伪标签。具体做法是通过选择最频繁的答案为每个唯一输入创建一个共识输出；在平局的情况下，启发式地选择最短的答案。使用了zeno-build做并行。</p><h2 id="model-retriever">Model Retriever</h2><figure><img src="https://cdn.studyinglover.com/pic/2023/09/413a97d48cf68b35b004601c0fbd4446.png" alt="" /><figcaption>image.png</figcaption></figure><p>这是一个检索类问题。作者选择encoder-decoder的架构，但是仍然有非常多的选择，像Salesforce/codet5-base，MaryaAI/opus-mt-ar-en-finetuned-ar-to-en，所以作为一个检索类问题使用用户的指令作为查询，搜索 Hugging Face 上模型的所有文本描述。 <img src="https://cdn.studyinglover.com/pic/2023/09/7f7790be882200d87972f87e06697d8f.png" alt="image.png" /> ，考虑到对模型的描述一般是比较稀疏并且包含大量模板文本，这里作者使用gpt-3.5-turbo生成了模型可能的描述，用 BM25 算法来计算查询模型相似度分数。</p><p>为了模型易部署，作者过滤了大于3gb的所有模型，同时引入了一个直觉，下载量越高的模型效果越好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;prompt2model笔记&quot;&gt;prompt2model笔记&lt;/h1&gt;
&lt;p&gt;prompt2model是一个通过提示自动生成语言模型的方法&lt;/p&gt;
&lt;p&gt;项目地址&lt;a href=&quot;https://github.com/neulab/prompt2model&quot;&gt;Gi</summary>
      
    
    
    
    <category term="笔记" scheme="https://studyinglover.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="自然语言处理" scheme="https://studyinglover.com/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>RoboTAP笔记</title>
    <link href="https://studyinglover.com/2023/09/01/RoboTAP%E7%AC%94%E8%AE%B0/"/>
    <id>https://studyinglover.com/2023/09/01/RoboTAP%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-01T12:35:00.000Z</published>
    <updated>2023-10-18T10:59:56.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="robotap笔记">RoboTAP笔记</h1><p>RoboTAP是一种基于点追踪技术的少样本视觉模仿方法，可以实现机器人在多个任务和场景中的精准操作。</p><p>项目主页<a href="https://robotap.github.io/">GitHub</a></p><p>RoboTAP不需要任何特定于任务的训练或神经网络微调。由于TAP的普适性，作者发现添加新任务（包括调整超参数）只需几分钟，这比我们熟悉的任何操纵系统都快几个数量级。作者认为这种能力在大规模自主数据收集和作为解决现实任务的解决方案方面可能非常有用。RoboTAP在需要快速教授视觉运动技能并且可以轻松演示所需行为的情况下最有用。</p><p>RoboTAP存在一些重要的限制。首先，低级控制器是纯视觉的，这排除了复杂的运动规划或力控制行为。其次，目前计算运动计划一次并在没有重新规划的情况下执行它，这可能会导致单个行为失败或环境意外改变。</p><p>作者在论文中指出他有四个贡献</p><ol type="1"><li>在密集跟踪方面制定多任务操作问题</li><li>RoboTAP的具体实现是什么，在哪里以及如何以visual-saliency，temporal-alignment, 和 visual-servoing的形式解决问题</li><li>一个新的密集跟踪数据集，其中包含为RoboTAP任务量身定制的ground-truth人工注释，并在专注于真实世界机器人操作的TAP-Vid基准上进行评估</li><li>描述了RoboTAP在涉及精确多体重排、变形物体和不可逆行动的一系列操作任务中的成功和失败模式的实证结果。</li></ol><figure><img src="https://cdn.studyinglover.com/pic/2023/08/15ff4915dff842e47e91d580d0d0fe5c.png" alt="" /><figcaption>image.png</figcaption></figure><p>RoboTAP方法的核心是利用TAPIR密集地跟踪一组演示，将演示分段，并自动发现每个阶段的活动点集q，该点集覆盖在该动作阶段相关的物体上。然后，我们形成一个可以在机器人上执行的运动计划，其中包括模仿视觉运动和基本的电机原语，例如关闭和打开夹爪的阶段。通过使用TAPIR检测点q，找到最近的演示，显示如何移动这些点，并找到可以用作运动目标的单个附近帧来实现视觉伺服。将目标帧（g）和在线TAPIR检测之间的位移用作经典视觉伺服的运动目标，从而产生出奇异复杂和强健的行为。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;robotap笔记&quot;&gt;RoboTAP笔记&lt;/h1&gt;
&lt;p&gt;RoboTAP是一种基于点追踪技术的少样本视觉模仿方法，可以实现机器人在多个任务和场景中的精准操作。&lt;/p&gt;
&lt;p&gt;项目主页&lt;a href=&quot;https://robotap.github.io/&quot;&gt;GitH</summary>
      
    
    
    
    <category term="笔记" scheme="https://studyinglover.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="多模态" scheme="https://studyinglover.com/tags/%E5%A4%9A%E6%A8%A1%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>自建obsidian同步服务</title>
    <link href="https://studyinglover.com/2023/08/31/%E8%87%AA%E5%BB%BAobsidian%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1/"/>
    <id>https://studyinglover.com/2023/08/31/%E8%87%AA%E5%BB%BAobsidian%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1/</id>
    <published>2023-08-31T15:47:00.000Z</published>
    <updated>2023-10-18T10:59:56.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自建obsidian同步服务">自建obsidian同步服务</h1><p>最近GitHub上有这样一个项目<a href="https://github.com/acheong08/rev-obsidian-sync">rev-obsidian-sync</a> ,他逆向了obsidian的同步服务，使其可以在本地运行。</p><h2 id="服务端">服务端</h2><h3 id="安装">安装</h3><p>首先安装服务端， <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/acheong08/rev-obsidian-sync<br><span class="hljs-built_in">cd</span> obsidian-sync<br>go run cmd/obsidian-sync/main.go<br></code></pre></td></tr></table></figure> go会下载一堆依赖，然后你会在最下面看到这个 <img src="https://cdn.studyinglover.com/pic/2023/08/c41aa8aca8c8033d319317ee2dbc3643.png" alt="image.png" /></p><p>当然你也可以自定义域名，设置环境变量，<code>DOMAIN_NAME</code> 设置域名，<code>ADDR_HTTP</code>设置监听端口，<code>DATA_DIR</code> 设置数据保存的文件夹，<code>SIGNUP_KEY</code> 设置注册的密钥。</p><h3 id="创建用户">创建用户</h3><p>需要新建一个用户给自己 <code>go run cmd/signup/main.go</code> 在命令行按照提示输入邮箱密码。</p><p>或者使用http请求的方式 <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">curl <span class="hljs-params">--request</span> POST \<br>  <span class="hljs-params">--url</span> https:<span class="hljs-string">//yourdomain.com/user/signup</span> \<br>  <span class="hljs-params">--header</span> &#x27;Content-Type: application/json&#x27; \<br>  <span class="hljs-params">--data</span> &#x27;&#123;<br><span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;example@example.com&quot;</span>,<br><span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;example_password&quot;</span>,<br><span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Example User&quot;</span>,<br><span class="hljs-string">&quot;signup_key&quot;</span>: <span class="hljs-string">&quot;&lt;SIGNUP_KEY&gt;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="客户端">客户端</h2><p>在obsidian仓库打开命令行，然后 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /path/to/vault/.obsidian<br><span class="hljs-built_in">mkdir</span> -p plugins/custom-sync-plugin &amp;&amp; <span class="hljs-built_in">cd</span> plugins/custom-sync-plugin<br>wget https://github.com/acheong08/rev-obsidian-sync-plugin/raw/master/main.js https://github.com/acheong08/rev-obsidian-sync-plugin/raw/master/manifest.json<br></code></pre></td></tr></table></figure> 打开obsidian设置界面，选择第三方插件，启用<code>Custom Native Sync</code> <img src="https://cdn.studyinglover.com/pic/2023/08/0a124be82a4a2fe13b1943ab320c839d.png" alt="image.png" /></p><p>设置服务端地址 <img src="https://cdn.studyinglover.com/pic/2023/08/9b7c177f4b69baed6686fffca3a04df5.png" alt="image.png" /></p><p>同时打开核心插件的同步 <img src="https://cdn.studyinglover.com/pic/2023/08/e3944c723e5b4ea0740f729fdd4a1c73.png" alt="image.png" /> 在点击左侧出现的同步按钮，输入前面设置的账号密码，就可以体验到官方的同步功能了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自建obsidian同步服务&quot;&gt;自建obsidian同步服务&lt;/h1&gt;
&lt;p&gt;最近GitHub上有这样一个项目&lt;a href=&quot;https://github.com/acheong08/rev-obsidian-sync&quot;&gt;rev-obsidian-sync&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MediaPipe即将推出图像生成服务</title>
    <link href="https://studyinglover.com/2023/08/23/MediaPipe%E5%8D%B3%E5%B0%86%E6%8E%A8%E5%87%BA%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90%E6%9C%8D%E5%8A%A1/"/>
    <id>https://studyinglover.com/2023/08/23/MediaPipe%E5%8D%B3%E5%B0%86%E6%8E%A8%E5%87%BA%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90%E6%9C%8D%E5%8A%A1/</id>
    <published>2023-08-23T20:42:00.000Z</published>
    <updated>2023-10-18T10:59:56.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mediapipe即将推出图像生成服务">MediaPipe即将推出图像生成服务</h1><p>今天我逛GitHub Trending的时候突然发现MediaPipe的示例库被顶到了前排 <img src="https://cdn.studyinglover.com/pic/2023/08/0bc3379fab3273262e8b6f14799b629a.png" alt="image.png" /></p><p>这不对劲，我赶紧去mediapipe的储存库，发现7个小时前Google推送了新的内容 <a href="https://github.com/google/mediapipe/commit/2ebdb01d4326c934e0628e7ff45cadda6575d23f">ImageGenerator Java API</a> <img src="https://cdn.studyinglover.com/pic/2023/08/b744863d78b3347dc0cfb23c7a0cd29d.png" alt="image.png" /></p><p>原来MediaPipe也要推出文字生成图片内容啊，还是移动端设备上的，这让我想起来GitHub最近有人开始写stable-diffusion.cpp，一个使用了ggml量化加速的sd。</p><p>顺藤摸瓜我们可以找到MediaPipe的<a href="https://developers.google.com/mediapipe/solutions/vision/image_generator">文档</a>。 <img src="https://cdn.studyinglover.com/pic/2023/08/6c50982c58e1d65562e230b0bb601d15.png" alt="image.png" /></p><p>还是即将推出状态，但是给了一个简单示例。</p><p>用法超级简单，就是下载下面几个模型中的一个 - <a href="https://huggingface.co/runwayml/stable-diffusion-v1-5/blob/main/v1-5-pruned-emaonly.ckpt">runwayml/stable-diffusion-v1-5</a> - <a href="https://huggingface.co/justinpinkney/miniSD/blob/main/miniSD.ckpt">justinpinkney/miniSD</a> - <a href="https://huggingface.co/hakurei/waifu-diffusion-v1-4/blob/main/models/wd-1-3-penultimate-ucg-cont.ckpt">hakurei/waifu-diffusion-v1-4</a> - <a href="https://huggingface.co/Fictiverse/Stable_Diffusion_PaperCut_Model/blob/main/PaperCut_v1.ckpt">Fictiverse/Stable_Diffusion_PaperCut_Model</a></p><p>安装依赖 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install torch typing_extensions numpy Pillow requests pytorch_lightning absl-py<br></code></pre></td></tr></table></figure> 把这个文件copy下来,<a href="https://github.com/googlesamples/mediapipe/blob/main/tools/image_generator_converter/convert.py">地址</a></p><p>然后 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 convert.py --ckpt_path &lt;ckpt_path&gt; --output_path &lt;output_path&gt;<br></code></pre></td></tr></table></figure></p><p>接着将文件夹内容<code>&lt;output_path&gt;</code>推送到 Android 设备。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb shell <span class="hljs-built_in">rm</span> -r /data/local/tmp/image_generator/ <br><br>adb shell <span class="hljs-built_in">mkdir</span> -p /data/local/tmp/image_generator/<br><br>adb push &lt;output_path&gt;/. /data/local/tmp/image_generator/bins<br></code></pre></td></tr></table></figure> 安装 Android 演示应用程序,在<a href="https://storage.googleapis.com/mediapipe-tasks/image_generator/imagegenerator.apk">这里</a>下载 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adb install imagegenerator.apk<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mediapipe即将推出图像生成服务&quot;&gt;MediaPipe即将推出图像生成服务&lt;/h1&gt;
&lt;p&gt;今天我逛GitHub Trending的时候突然发现MediaPipe的示例库被顶到了前排 &lt;img src=&quot;https://cdn.studyinglover.c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Dual-Stream Diffusion Net for Text-to-Video Generation笔记</title>
    <link href="https://studyinglover.com/2023/08/23/DSDN%E7%AC%94%E8%AE%B0/"/>
    <id>https://studyinglover.com/2023/08/23/DSDN%E7%AC%94%E8%AE%B0/</id>
    <published>2023-08-23T10:32:00.000Z</published>
    <updated>2023-10-18T10:59:56.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dual-stream-diffusion-net-for-text-to-video-generation笔记">Dual-Stream Diffusion Net for Text-to-Video Generation笔记</h1><p>这篇论文提出的模型架构是Dual-Stream Diffusion Net（DSDN），它是一种双流扩散网络。</p><figure><img src="https://cdn.studyinglover.com/pic/2023/08/3021b6624ee4f2093c6166b6a80cd643.png" alt="" /><figcaption>image.png</figcaption></figure><p>首先，视频内容通过一个一个编码器编码成内容特征和一个动作编码器编码成动作特征，并通过一个增量学习模块进行更新。前向扩散过程没有使用DDPM而是使用了 Hierarchical Text-Conditional Image Generation with CLIP Latents 这篇论文提出的方法。</p><p>为了对齐生成的内容和运动，设计了一个双流转换交互模块来通过交叉注意力实现两个分支之间的信息交互和对齐。</p><p>最后引入了运动合成器来简化运动信息的操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;dual-stream-diffusion-net-for-text-to-video-generation笔记&quot;&gt;Dual-Stream Diffusion Net for Text-to-Video Generation笔记&lt;/h1&gt;
&lt;p&gt;这篇论文提出的模型</summary>
      
    
    
    
    <category term="笔记" scheme="https://studyinglover.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="文字生成图片" scheme="https://studyinglover.com/tags/%E6%96%87%E5%AD%97%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>ViT在DDPM取代UNet(DiT)</title>
    <link href="https://studyinglover.com/2023/08/20/ViT%E5%9C%A8DDPM%E5%8F%96%E4%BB%A3UNet(DiT)/"/>
    <id>https://studyinglover.com/2023/08/20/ViT%E5%9C%A8DDPM%E5%8F%96%E4%BB%A3UNet(DiT)/</id>
    <published>2023-08-20T09:43:00.000Z</published>
    <updated>2023-10-18T10:59:56.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vit在ddpm取代unetdit">ViT在DDPM取代UNet(DiT)</h1><p><a href="https://www.wpeebles.com/DiT.html">项目主页</a></p><p>这篇论文主要是尝试使用ViT取代DDPM中的UNet，叫做Diffusion Transformer-DiT，作者训练了DiT-S、DiT-B、DiT-L 和 DiT-XL四种模型，每种模型的patch取8,4,2, 一共训练了12个模型。</p><p>作者探索的完整 DiT 设计空间是补丁大小、变压器块架构和模型大小。</p><p>模型第一层是对 sequences of patches 进行操作(就是ViT把图片看成<span class="math inline">\(16*16\)</span>的的单词之后单词构成的序列) 。 <img src="https://cdn.studyinglover.com/pic/2023/08/d9b9a168f177471d890c1bd3e3f2cc2d.png" alt="image.png" /></p><p>如图所示，给定的patch是<span class="math inline">\(p\times p\)</span> ,VAE采样出来的噪声大小是<span class="math inline">\(I\times I\times C\)</span> ,那么patches会变成长度为<span class="math inline">\(T=(I/\hat{p})^{2}\)</span> 的一个序列,每个patch维度是<span class="math inline">\(d\)</span> ,位置嵌入用的是sine-cosine。</p><p>接下来就是diffusion transformers的设计。 <img src="https://cdn.studyinglover.com/pic/2023/08/f68c4f271029a484e97822dbb9fb2569.png" alt="image.png" /></p><p>作者提到了一点，就是获取到path序列之后应该在后面加上去噪步数和类别标签，并在最后一个DiT块之后删掉。</p><p>在最终的 DiT 块之后，需要将输出解码为噪声预测和对角协方差预测。这两个输出的形状都等于整个模型的输入。作者使用标准线性解码器来做到这一点。如果使用 adaLN 自适应就应用最后一层范数，并将每个标记线性解码为 <span class="math inline">\(p\times p\times2C\)</span> 张量，其中 <span class="math inline">\(C\)</span> 是输入到DiT的空间大小。最后，将解码的token重新排列到其原始空间布局中，得到预测的噪声和协方差。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vit在ddpm取代unetdit&quot;&gt;ViT在DDPM取代UNet(DiT)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.wpeebles.com/DiT.html&quot;&gt;项目主页&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇论文主要是尝试使用ViT取代DDPM中的UNe</summary>
      
    
    
    
    <category term="笔记" scheme="https://studyinglover.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="文字生成图片" scheme="https://studyinglover.com/tags/%E6%96%87%E5%AD%97%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>arch4edu搞崩了我的flutter</title>
    <link href="https://studyinglover.com/2023/08/19/arch4edu%E6%90%9E%E5%B4%A9%E4%BA%86%E6%88%91%E7%9A%84flutter/"/>
    <id>https://studyinglover.com/2023/08/19/arch4edu%E6%90%9E%E5%B4%A9%E4%BA%86%E6%88%91%E7%9A%84flutter/</id>
    <published>2023-08-19T21:36:00.000Z</published>
    <updated>2023-10-18T10:59:56.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="arch4edu搞崩了我的flutter">arch4edu搞崩了我的flutter</h1><p>今天是快乐的一天，适合滚包 <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yay</span><br></code></pre></td></tr></table></figure> 一切安好，arch4edu说我的flutter需要更新 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">==&gt; 要排除的包: (示例: <span class="hljs-string">&quot;1 2 3&quot;</span>, <span class="hljs-string">&quot;1-3&quot;</span>, <span class="hljs-string">&quot;^4&quot;</span> 或软件库名称)<br> -&gt; 排除软件包可能会导致不完整的升级并破坏系统<br>==&gt; <br><br></code></pre></td></tr></table></figure> 没什么需要排除的，接下来就是愉快的自动安装</p><p>突然我看到了这个</p><figure><img src="https://cdn.studyinglover.com/pic/2023/08/d257220b6c5bc01465f92fdd72320344.png" alt="" /><figcaption>image.png</figcaption></figure><p>警告啦，没啥好担心的啦，待会跑一下看好着没</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">flutter doctor                     <br>Found an existing Pub cache at /home/zjh/.pub-cache.<br>It can be repaired by running `dart pub cache repair`.<br>It can be reset by running `dart pub cache clean`.<br>Found an existing Dart Analysis Server cache at /home/zjh/.dartServer.<br>It can be reset by deleting /home/zjh/.dartServer.<br>Flutter failed to write to a file at <span class="hljs-string">&quot;/opt/flutter/packages/flutter_tools/.dart_tool/version&quot;</span>.<br>Please ensure that the SDK and/or project is installed <span class="hljs-keyword">in</span> a location that has <span class="hljs-built_in">read</span>/write<br>permissions <span class="hljs-keyword">for</span> the current user.<br>Try running:<br>  sudo <span class="hljs-built_in">chown</span> -R $(<span class="hljs-built_in">whoami</span>) /opt/flutter/packages/flutter_tools/.dart_tool/version<br><br></code></pre></td></tr></table></figure><p>好的他炸了</p><p>看着问题不大，就是读写权限的问题，的问题？鬼知道会有啥问题，我决定让arch4edu滚蛋</p><p>先<code>sudo pacman -Rns flutter</code>把arch4edu的flutter删掉，然后去<code>/etc/pacman.conf</code> 删除了arch4edu镜像，再<code>sudo pacman -Syu</code>滚一遍包，最后<code>yay flutter</code></p><p>中间会有一个问题 <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts">错误：无法提交处理 (有冲突的文件)<br><span class="hljs-symbol">flutter:</span> 文件系统中已存在 <span class="hljs-keyword">/opt/</span>flutter<span class="hljs-keyword">/bin/</span>cache/flutter_version_check.stamp <br>发生错误，没有软件包被更新。<br></code></pre></td></tr></table></figure> ok,sudo直接删就行，反正是cache</p><p>最后<code>flutter docker</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">Doctor summary (to see all details, run flutter doctor -v):<br>[✓] Flutter (Channel stable, 3.13.0, on Arch Linux 6.4.10-arch1-1, locale zh_CN.UTF-8)<br>[✓] Android toolchain - develop <span class="hljs-keyword">for</span> Android devices (Android SDK version 34.0.0)<br>[✓] Chrome - develop <span class="hljs-keyword">for</span> the web<br>[✓] Linux toolchain - develop <span class="hljs-keyword">for</span> Linux desktop<br>[✓] Android Studio (version 2022.2)<br>[✓] Connected device (2 available)<br>[✓] Network resources<br><br>• No issues found!<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;arch4edu搞崩了我的flutter&quot;&gt;arch4edu搞崩了我的flutter&lt;/h1&gt;
&lt;p&gt;今天是快乐的一天，适合滚包 &lt;figure class=&quot;highlight ebnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LISA(推理分割)笔记</title>
    <link href="https://studyinglover.com/2023/08/18/LISA(%E6%8E%A8%E7%90%86%E5%88%86%E5%89%B2)%E7%AC%94%E8%AE%B0/"/>
    <id>https://studyinglover.com/2023/08/18/LISA(%E6%8E%A8%E7%90%86%E5%88%86%E5%89%B2)%E7%AC%94%E8%AE%B0/</id>
    <published>2023-08-18T15:05:00.000Z</published>
    <updated>2023-10-18T10:59:56.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lisa推理分割笔记">LISA(推理分割)笔记</h1><h2 id="简介">简介</h2><p>这篇论文题目中文翻译是 基于大型语言模型的语义分割， 提出了一个新任务-推理分割。大概就是给一张图和一段话，模型使用大语言模型分割出目标。作者给了一个例子，从图片中分割出富含维生素C的物品。</p><p>作者说这篇论文有三个贡献，提出了推理分割的任务，建立了一个推理分割基准，ReasonSeg， 还有训练了一个模型。</p><p>项目主页<a href="https://github.com/dvlab-research/LISA">GitHub</a></p><p>LISA可以完成四种任务 1) complex reasoning; 2) world knowledge; 3) explanatory answers; 4) multi-turn conversation</p><h2 id="模型架构">模型架构</h2><h3 id="生成mask">生成mask</h3><p>这里作者提出了一些问题，就是大部分llm是不具备视觉能力，有视觉能力的泛化型不好还不好训练。相比之下，训练 LISA-7B 在 8 个 NVIDIA 24G 3090 GPU 上只需要 10,000 个训练步骤。(嗯8块3090)</p><p><img src="https://cdn.studyinglover.com/pic/2023/08/ded90e7e3f84739b187dd679c39bd8dd.png" alt="image.png" /> 模型结构就是上面这张图，右下角标了火花的就说明是需要训练或者微调的。首先扩充词表，加入<code>&lt;SEG&gt;</code> ,接下来给出一张图片<span class="math inline">\(x_{img}\)</span>和一段文本<span class="math inline">\(x_{txt}\)</span>, 将他们送入大语言模型<span class="math inline">\(\mathcal{F}\)</span> ,写成公式就是<span class="math display">\[\hat{\boldsymbol{y}}_{txt}=\mathcal{F}(x_{img},\boldsymbol{x}_{txt}).\]</span> 当LLM倾向于生成二进制分割掩码时，输出<span class="math inline">\(\hat{\boldsymbol{y}}_{txt}\)</span>应该包含一个<code>&lt;SEG&gt;</code>令牌。所以提取最后一层嵌入<span class="math inline">\(\hat{h}_{seg}\)</span> (因为他和<code>&lt;SEG&gt;</code> token 是相关的)， 并用一个MLP <span class="math inline">\(\gamma\)</span> 将其投影到<span class="math inline">\(h_{seg}\)</span>。</p><p>同时，视觉编码器<span class="math inline">\(\mathcal{F_{enc}}\)</span> 会从图片中提取出视觉特征<span class="math inline">\(\text{f}\)</span> 。</p><p>最后<span class="math inline">\(h_{seg}\)</span>和<span class="math inline">\(\text{f}\)</span> 会被送入一个和SAM有相同架构的解码器，获得最后的mask.</p><p>整个过程表示出来就是<span class="math display">\[\begin{gathered}\boldsymbol{h}_{seg}=\gamma(\hat{\boldsymbol{h}}_{seg}),\quad\boldsymbol{f}=\mathcal{F}_{enc}(\boldsymbol{x}_{img}),\\\hat{\boldsymbol{M}}=\mathcal{F}_{dec}(\boldsymbol{h}_{seg},\boldsymbol{f}).\end{gathered}\]</span> ### 训练目标 训练目标是文本生成损失 <span class="math inline">\(\mathcal{L}_{txt}\)</span> 和分割掩码损失 <span class="math inline">\(\mathcal{L}_{mask}\)</span> 进行端到端训练。总体目标 <span class="math inline">\(L\)</span> 是这些损失的加权和，由 <span class="math inline">\(\lambda_{txt}\)</span> 和 <span class="math inline">\(\lambda_{mask}\)</span> 确定<span class="math display">\[\mathcal{L}=\lambda_{txt}\mathcal{L}_{txt}+\lambda_{mask}\mathcal{L}_{mask}.\]</span> ## 训练 ### 数据集 训练数据由三部分组成，都是开源数据集 1. Semantic Segmentation Dataset 2. Vanilla Referring Segmentation Dataset 3. Visual Question Answering Dataset</p><p><strong>值得注意的是，LISA具有zero-shot能力，因为训练集不包含任何推理分割的内容。</strong></p><h3 id="需要训练的参数">需要训练的参数</h3><p>为了保持llm的泛化能力作者用了lora,解码器可以被微调，llm的词嵌入和投影最后一层潜入的mlp也可以微调</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lisa推理分割笔记&quot;&gt;LISA(推理分割)笔记&lt;/h1&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;这篇论文题目中文翻译是 基于大型语言模型的语义分割， 提出了一个新任务-推理分割。大概就是给一张图和一段话，模型使用大语言模型分割出目标。作者给了一个例子，从</summary>
      
    
    
    
    <category term="笔记" scheme="https://studyinglover.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="多模态" scheme="https://studyinglover.com/tags/%E5%A4%9A%E6%A8%A1%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>在终端绘制GPU显存使用曲线</title>
    <link href="https://studyinglover.com/2023/08/13/%E5%9C%A8%E7%BB%88%E7%AB%AF%E7%BB%98%E5%88%B6GPU%E6%98%BE%E5%AD%98%E4%BD%BF%E7%94%A8%E6%9B%B2%E7%BA%BF/"/>
    <id>https://studyinglover.com/2023/08/13/%E5%9C%A8%E7%BB%88%E7%AB%AF%E7%BB%98%E5%88%B6GPU%E6%98%BE%E5%AD%98%E4%BD%BF%E7%94%A8%E6%9B%B2%E7%BA%BF/</id>
    <published>2023-08-13T11:44:00.000Z</published>
    <updated>2023-10-18T10:59:56.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在终端绘制gpu显存使用曲线">在终端绘制GPU显存使用曲线</h1><p>这个东西的灵感来自于写torch的时候想实时看到loss和gpu使用情况，突然想到可以在终端实时显示，经过与ai的一番激烈讨，最终有了这个代码。</p><p>我们首先要获取GPU的显存使用数据，先检查是否安装了<code>nvidia-smi</code>, 在终端输入有正常输出即可。</p><p>首先导入所有需要的库 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> asciichartpy<br><span class="hljs-keyword">import</span> platform<br></code></pre></td></tr></table></figure></p><p>通过<code>nvidia-smi</code> 的命令获取已经使用的显存和所有现存 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_gpu_used_memory</span>():<br>output = subprocess.check_output([<span class="hljs-string">&#x27;nvidia-smi&#x27;</span>, <span class="hljs-string">&#x27;--query-gpu=memory.used&#x27;</span>, <span class="hljs-string">&#x27;--format=csv,nounits&#x27;</span>])<br>output = output.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>lines = output.strip().split(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>used_memory = <span class="hljs-built_in">int</span>(lines[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">return</span> used_memory<br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_gpu_total_memory</span>():<br>output = subprocess.check_output([<span class="hljs-string">&#x27;nvidia-smi&#x27;</span>, <span class="hljs-string">&#x27;--query-gpu=memory.total&#x27;</span>, <span class="hljs-string">&#x27;--format=csv,nounits&#x27;</span>])<br>output = output.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>lines = output.strip().split(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>total_memory = <span class="hljs-built_in">int</span>(lines[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">return</span> total_memory<br></code></pre></td></tr></table></figure></p><p><code>asciichartpy</code> 是一个 Python 库，用于在终端中绘制 ASCII 图表。我们用他来在终端绘制图标。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_gpu_memory</span>(<span class="hljs-params">gpu_memory_history</span>):<br>    used_memory = get_gpu_used_memory()<br>    total_memory = get_gpu_total_memory()<br><br>    used_percentage = used_memory / total_memory * <span class="hljs-number">100</span><br>    gpu_memory_history.append(used_percentage)<br><br>    <span class="hljs-comment"># 绘制字符图表</span><br>    chart = asciichartpy.plot(gpu_memory_history, &#123;<span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;timestamp&#x27;</span>: <span class="hljs-literal">True</span>&#125;)<br>    <br>    <span class="hljs-comment"># 清空终端屏幕</span><br>    <span class="hljs-keyword">if</span> platform.system() == <span class="hljs-string">&#x27;Windows&#x27;</span>:<br>        subprocess.call(<span class="hljs-string">&#x27;cls&#x27;</span>, shell=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">else</span>:<br>        subprocess.call(<span class="hljs-string">&#x27;clear&#x27;</span>, shell=<span class="hljs-literal">True</span>)<br>    <br>    <span class="hljs-built_in">print</span>(chart)<br></code></pre></td></tr></table></figure></p><p>最后运行上面的代码 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        gpu_memory_history = []<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            draw_gpu_memory(gpu_memory_history)<br>            time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure> 运行效果 <img src="https://cdn.studyinglover.com/pic/2023/08/c320d69a8169e36fab4c82f1725c298b.png" alt="image.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在终端绘制gpu显存使用曲线&quot;&gt;在终端绘制GPU显存使用曲线&lt;/h1&gt;
&lt;p&gt;这个东西的灵感来自于写torch的时候想实时看到loss和gpu使用情况，突然想到可以在终端实时显示，经过与ai的一番激烈讨，最终有了这个代码。&lt;/p&gt;
&lt;p&gt;我们首先要获取GPU的显存</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GPTBot介绍</title>
    <link href="https://studyinglover.com/2023/08/11/GPTBot%E4%BB%8B%E7%BB%8D/"/>
    <id>https://studyinglover.com/2023/08/11/GPTBot%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-08-11T20:58:00.000Z</published>
    <updated>2023-10-18T10:59:56.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gptbot介绍">GPTBot介绍</h1><p>最近，openai公布了<a href="https://platform.openai.com/docs/gptbot/gptbot">GPTBot</a> 的相关信息，并给出了禁止GPTBot的方法。以下是全文翻译。</p><p>GPTBot是OpenAI的网络爬虫，可以通过以下User agent和字符串来识别。 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">User</span> agent token: GPTBot<br><span class="hljs-attribute">Full</span> user-agent string: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko; compatible; GPTBot/<span class="hljs-number">1</span>.<span class="hljs-number">0</span>; +https://openai.com/gptbot)<br></code></pre></td></tr></table></figure></p><h2 id="使用">使用</h2><p>使用 GPTBot 用户代理爬取的网页可能会用于改进未来的模型，并且会过滤掉需要付费访问、已知收集个人身份信息（PII）或含有违反我们政策的文本的来源。允许 GPTBot 访问您的网站可以帮助 AI 模型变得更准确，提高它们的一般能力和安全性。在下面，我们还分享了如何禁止 GPTBot 访问您的网站。</p><h3 id="禁止-gptbot">禁止 GPTBot</h3><p>要禁止 GPTBot 访问您的网站，您可以将 GPTBot 添加到您网站的 robots.txt： <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">User-agent</span><span class="hljs-punctuation">: </span>GPTBot<br><span class="hljs-attribute">Disallow</span><span class="hljs-punctuation">: </span>/<br></code></pre></td></tr></table></figure></p><h3 id="自定义-gptbot-访问">自定义 GPTBot 访问</h3><p>要允许 GPTBot 仅访问您网站的部分内容，您可以将 GPTBot 令牌添加到您网站的 robots.txt，如下所示： <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts">User-agent: GPTBot<br><span class="hljs-symbol">Allow:</span> <span class="hljs-keyword">/directory-1/</span><br><span class="hljs-symbol">Disallow:</span> <span class="hljs-keyword">/directory-2/</span><br></code></pre></td></tr></table></figure></p><h3 id="ip-出口范围">IP 出口范围</h3><p>对于 OpenAI 的爬虫，它会从 <a href="https://openai.com/gptbot-ranges.txt">OpenAI 网站</a>上记录的 IP 地址段向网站发出请求。</p><p>这里我给出IP 地址段 <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">20.15.240.64</span>/<span class="hljs-number">28</span><br><span class="hljs-number">20.15.240.80</span>/<span class="hljs-number">28</span><br><span class="hljs-number">20.15.240.96</span>/<span class="hljs-number">28</span><br><span class="hljs-number">20.15.240.176</span>/<span class="hljs-number">28</span><br><span class="hljs-number">20.15.241.0</span>/<span class="hljs-number">28</span><br><span class="hljs-number">20.15.242.128</span>/<span class="hljs-number">28</span><br><span class="hljs-number">20.15.242.144</span>/<span class="hljs-number">28</span><br><span class="hljs-number">20.15.242.192</span>/<span class="hljs-number">28</span><br><span class="hljs-number">40.83.2.64</span>/<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gptbot介绍&quot;&gt;GPTBot介绍&lt;/h1&gt;
&lt;p&gt;最近，openai公布了&lt;a href=&quot;https://platform.openai.com/docs/gptbot/gptbot&quot;&gt;GPTBot&lt;/a&gt; 的相关信息，并给出了禁止GPTBot的方法。以下是</summary>
      
    
    
    
    
  </entry>
  
</feed>
