<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>plus studio</title>
  
  
  <link href="https://studyinglover.com/atom.xml" rel="self"/>
  
  <link href="https://studyinglover.com/"/>
  <updated>2024-02-03T15:39:26.041Z</updated>
  <id>https://studyinglover.com/</id>
  
  <author>
    <name>StudyingLover</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fastapi集成google auth登录</title>
    <link href="https://studyinglover.com/2024/01/21/fastapi%E9%9B%86%E6%88%90google%20auth%E7%99%BB%E5%BD%95/"/>
    <id>https://studyinglover.com/2024/01/21/fastapi%E9%9B%86%E6%88%90google%20auth%E7%99%BB%E5%BD%95/</id>
    <published>2024-01-21T10:26:00.000Z</published>
    <updated>2024-02-03T15:39:26.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fastapi集成google-auth登录">fastapi集成google auth登录</h1><h2 id="流程设计">流程设计</h2><h3 id="启动-google-登录流程">1. 启动 Google 登录流程</h3><ul><li><strong>前端</strong>：用户点击 Google 登录按钮。</li><li><strong>请求</strong>：前端发起请求到 <code>/user/login/google</code>。</li></ul><h3 id="后端处理-userlogingoogle-请求">2. 后端处理 <code>/user/login/google</code> 请求</h3><ul><li>后端生成一个重定向到 Google 认证服务器的 URL</li><li>后端将此 URL 发送给前端。</li></ul><h3 id="前端重定向">3. 前端重定向</h3><ul><li>前端接收到 URL 后，重定向用户到 Google 的登录页面。</li></ul><h3 id="用户登录并授权">4. 用户登录并授权</h3><ul><li>用户在 Google 页面上授权你的应用。</li></ul><h3 id="google-重定向回你的应用">5. Google 重定向回你的应用</h3><ul><li>Google 将用户重定向回你的应用，并在查询参数中附加一个授权码（code）。</li></ul><h3 id="前端发送授权码">6. 前端发送授权码</h3><ul><li><strong>前端</strong>：捕获此授权码并发送到 <code>/user/auth/google?code=$&#123;code&#125;</code>。</li><li><strong>请求</strong>：<code>POST /user/auth/google?code=$&#123;code&#125;</code>。</li></ul><h3 id="后端处理-userauthgooglecodecode-请求">7. 后端处理 <code>/user/auth/google?code=$&#123;code&#125;</code> 请求</h3><ul><li>后端接收授权码，并使用它向 Google 请求访问令牌。</li><li>使用此令牌，后端可以从 Google 获取用户信息（如用户名、邮箱等）。</li><li>后端检查此用户是否已在数据库中。如果不在，创建一个新用户。</li><li>后端生成一个会话或令牌（如 JWT），并将其发送回前端。</li></ul><h3 id="前端接收令牌">8. 前端接收令牌</h3><ul><li>前端接收令牌并存储在本地（如 localStorage、sessionStorage 或 cookie 中）。</li></ul><h3 id="前端使用令牌">9. 前端使用令牌</h3><ul><li>对于后续请求，前端将此令牌附加到请求的授权头中，以验证用户身份。</li></ul><h3 id="后端验证令牌">10. 后端验证令牌</h3><ul><li>对于需要身份验证的后续请求，后端验证传入的令牌，以确认用户的身份。</li></ul><h2 id="获取google密钥">获取google密钥</h2><h3 id="创建项目">创建项目</h3><p>首先前往Google Cloud Console ( <a href="https://console.cloud.google.com/">https://console.cloud.google.com/</a> ) 并创建一个新项目（如果尚未创建），然后在“API 和服务 &gt; 仪表板”部分中启用“Google+ API”。你会在这样一个界面。</p><figure><img src="https://cdn.studyinglover.com/pic/2024/01/ae35717c51d89eb88ab6852b4b00ef63.png" alt="" /><figcaption>image.png</figcaption></figure><p>如果找不到的话，请先找到初始页面，选择一个项目，然后你会看到这样一个页面<img src="https://cdn.studyinglover.com/pic/2024/01/a92b558de8f9cff3830a4146d9632e59.png" alt="image.png" /></p><h3 id="创建oauth权限">创建OAuth权限</h3><p>按照如图顺序点击 <img src="https://cdn.studyinglover.com/pic/2024/01/101627cfb52eddde0622707fda8c787b.png" alt="image.png" /></p><p>进入之后就到了前面的页面，然后点击 OAuth权限请求页面</p><p><img src="https://cdn.studyinglover.com/pic/2024/01/3ab8147866777e9cc08572a85fbf6eb1.png" alt="image.png" /> 接下来我们会进入注册应用界面，首先填入的应用名称还有你的邮箱 <img src="https://cdn.studyinglover.com/pic/2024/01/001cbe727e68da69261b7ba012e596de.png" alt="image.png" /> 在最下面填上你的开发者信息，保存并继续 <img src="https://cdn.studyinglover.com/pic/2024/01/2398bdedeb782ff071e92f176815f251.png" alt="image.png" /></p><p>一路向下，可以填入一些限制，我就直接继续了。下面添加测试用户，填入google账号的邮箱即可 <img src="https://cdn.studyinglover.com/pic/2024/01/38893303361225188c4bf4b80a0da71c.png" alt="image.png" /> 保存，在摘要再检查一遍以后保存创建即可。接下来你会看到这样的页面，这样子我们的OAuth就设置好了。 <img src="https://cdn.studyinglover.com/pic/2024/01/adbcb7f78f4f157a5c3275cd48af66ec.png" alt="image.png" /></p><h3 id="创建凭据">创建凭据</h3><p>我们下面创建应用，点击凭据 <img src="https://cdn.studyinglover.com/pic/2024/01/1fd3b8f8bf2e42bbf21eba64619ab516.png" alt="image.png" /> 点击创建凭据 <img src="https://cdn.studyinglover.com/pic/2024/01/acd4317727c70cc5282b72d6350cb585.png" alt="image.png" /> 选择OAuth客户端ID <img src="https://cdn.studyinglover.com/pic/2024/01/cb1e787b42c9b3c0d5f95f2c9bf8bae2.png" alt="image.png" /></p><p>选择应用类型web应用 <img src="https://cdn.studyinglover.com/pic/2024/01/a334a3cf9bd76fa8c57fa0be48b6b713.png" alt="image.png" /></p><p>填写名称，已获授权的 JavaScript 来源，已获授权的重定向 URI。已获授权的 JavaScript 来源 写的是你的开发，测试还有正式环境的域名，例如<code>http://localhost:8000</code>。已获授权的重定向 URI 写的是你的重定向地址例如<code>http://localhost:8000/user/auth/google</code></p><figure><img src="https://cdn.studyinglover.com/pic/2024/01/ff16e3fd7c0c5eeeb82646f737a40f1f.png" alt="" /><figcaption>image.png</figcaption></figure><p>你会看到这样一个页面，保存你的客户端 ID和客户端密钥 <img src="https://cdn.studyinglover.com/pic/2024/01/c6ccc6b85da45c876f8194d099173bbe.png" alt="image.png" /> ## 代码实践</p><p>创建一个<code>.env</code>文件 <img src="https://cdn.studyinglover.com/pic/2024/01/73c325e34f0eaf971e44980543a09c00.png" alt="image.png" /></p><p>我们创建一个fastapi的后端 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Depends<br><span class="hljs-keyword">from</span> fastapi.security <span class="hljs-keyword">import</span> OAuth2PasswordBearer<br><span class="hljs-keyword">from</span> fastapi.middleware.cors <span class="hljs-keyword">import</span> CORSMiddleware<br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> jose <span class="hljs-keyword">import</span> jwt<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv<br><br>load_dotenv()<br><br><br>app = FastAPI()<br><br>app.add_middleware(<br>    CORSMiddleware,<br>    allow_origins=[<span class="hljs-string">&quot;*&quot;</span>],  <span class="hljs-comment"># Allows all origins</span><br>    allow_credentials=<span class="hljs-literal">True</span>,<br>    allow_methods=[<span class="hljs-string">&quot;*&quot;</span>],  <span class="hljs-comment"># Allows all methods</span><br>    allow_headers=[<span class="hljs-string">&quot;*&quot;</span>],  <span class="hljs-comment"># Allows all headers</span><br>)<br><br><br><span class="hljs-comment"># Replace these with your own values from the Google Developer Console</span><br>GOOGLE_CLIENT_ID = os.environ.get(<span class="hljs-string">&quot;GOOGLE_CLIENT_ID&quot;</span>)<br>GOOGLE_CLIENT_SECRET = os.environ.get(<span class="hljs-string">&quot;GOOGLE_CLIENT_SECRET&quot;</span>)<br>GOOGLE_REDIRECT_URI = <span class="hljs-string">&quot;http://localhost:8000/auth/google&quot;</span><br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/login/google&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">login_google</span>():<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">f&quot;https://accounts.google.com/o/oauth2/auth?response_type=code&amp;client_id=<span class="hljs-subst">&#123;GOOGLE_CLIENT_ID&#125;</span>&amp;redirect_uri=<span class="hljs-subst">&#123;GOOGLE_REDIRECT_URI&#125;</span>&amp;scope=openid%20profile%20email&amp;access_type=offline&quot;</span><br>    &#125;<br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/auth/google&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">auth_google</span>(<span class="hljs-params">code: <span class="hljs-built_in">str</span></span>):<br>    token_url = <span class="hljs-string">&quot;https://accounts.google.com/o/oauth2/token&quot;</span><br>    data = &#123;<br>        <span class="hljs-string">&quot;code&quot;</span>: code,<br>        <span class="hljs-string">&quot;client_id&quot;</span>: GOOGLE_CLIENT_ID,<br>        <span class="hljs-string">&quot;client_secret&quot;</span>: GOOGLE_CLIENT_SECRET,<br>        <span class="hljs-string">&quot;redirect_uri&quot;</span>: GOOGLE_REDIRECT_URI,<br>        <span class="hljs-string">&quot;grant_type&quot;</span>: <span class="hljs-string">&quot;authorization_code&quot;</span>,<br>    &#125;<br>    response = requests.post(token_url, data=data)<br>    access_token = response.json().get(<span class="hljs-string">&quot;access_token&quot;</span>)<br>    user_info = requests.get(<span class="hljs-string">&quot;https://www.googleapis.com/oauth2/v1/userinfo&quot;</span>, headers=&#123;<span class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string">f&quot;Bearer <span class="hljs-subst">&#123;access_token&#125;</span>&quot;</span>&#125;)<br>    <span class="hljs-built_in">print</span>(user_info.json())<br>    <span class="hljs-keyword">return</span> user_info.json()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn<br>    uvicorn.run(app, host=<span class="hljs-string">&quot;0.0.0.0&quot;</span>, port=<span class="hljs-number">8000</span>)<br></code></pre></td></tr></table></figure></p><p>同时我们需要一个前端，这里我们只有一个按钮来用于google登陆</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Login with Google<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleLogin</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:8000/login/google&#x27;</span>);</span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();</span><br><span class="language-javascript">            <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = data.<span class="hljs-property">url</span>;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRedirect</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> urlParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>);</span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> code = urlParams.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;code&#x27;</span>);</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (code) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`http://localhost:8000/auth/google?code=<span class="hljs-subst">$&#123;code&#125;</span>`</span>);</span><br><span class="language-javascript">                <span class="hljs-keyword">const</span> userData = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();</span><br><span class="language-javascript">                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;user-info&#x27;</span>).<span class="hljs-property">textContent</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(userData, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;handleRedirect()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;handleLogin()&quot;</span>&gt;</span>Login with Google<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user-info&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>点击按钮你会进入平时你看到的google登陆的流程，流程成功后你会在前端页面看到用户的信息</p><p>就像这样 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;13&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;a1@gmail.com&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;verified_email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;a &quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;given_name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;a&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;family_name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;a&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;picture&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;https://lh3.googleusercontent.com/a/ACLXM=s96-c&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;locale&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;zh-CN&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><p>同时后端也会在控制台打印出这个信息，我们已经成功通过了google的身份验证。我们可以再将他结合到自己的程序中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;fastapi集成google-auth登录&quot;&gt;fastapi集成google auth登录&lt;/h1&gt;
&lt;h2 id=&quot;流程设计&quot;&gt;流程设计&lt;/h2&gt;
&lt;h3 id=&quot;启动-google-登录流程&quot;&gt;1. 启动 Google 登录流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="google auth" scheme="https://studyinglover.com/tags/google-auth/"/>
    
    <category term="fastapi" scheme="https://studyinglover.com/tags/fastapi/"/>
    
    <category term="后端" scheme="https://studyinglover.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>linux下NTFS磁盘报错输入输出错误</title>
    <link href="https://studyinglover.com/2024/01/15/linux%E4%B8%8BNTFS%E7%A3%81%E7%9B%98%E6%8A%A5%E9%94%99%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%94%99%E8%AF%AF/"/>
    <id>https://studyinglover.com/2024/01/15/linux%E4%B8%8BNTFS%E7%A3%81%E7%9B%98%E6%8A%A5%E9%94%99%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%94%99%E8%AF%AF/</id>
    <published>2024-01-15T22:50:00.000Z</published>
    <updated>2024-02-03T15:39:26.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux下ntfs磁盘报错输入输出错误">linux下NTFS磁盘报错输入输出错误</h1><p>简单来说就是我在linux下挂载了一个NTFS格式的移动硬盘，然后在使用的时候，今天我想删除一个文件夹，突然给了我一个报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入/输出错误<br></code></pre></td></tr></table></figure><p>看到这个错误，我开了几个终端，又是<code>ntfsfix</code>修磁盘,又是<code>dmseg</code>看日志,一通操作猛如虎，问题依然没解决</p><p>这个时候我们注意到(attention is all you need)，ntfs是微软的闭源格式，linux下的ntfs-3g是一个开源的ntfs驱动，这个驱动是不是有问题呢？</p><p>关机，打开linux,扫描并修复磁盘，删除，问题解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux下ntfs磁盘报错输入输出错误&quot;&gt;linux下NTFS磁盘报错输入输出错误&lt;/h1&gt;
&lt;p&gt;简单来说就是我在linux下挂载了一个NTFS格式的移动硬盘，然后在使用的时候，今天我想删除一个文件夹，突然给了我一个报错&lt;/p&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>Venn-Abers 预测器</title>
    <link href="https://studyinglover.com/2024/01/15/Venn-Abers%20%E9%A2%84%E6%B5%8B%E5%99%A8/"/>
    <id>https://studyinglover.com/2024/01/15/Venn-Abers%20%E9%A2%84%E6%B5%8B%E5%99%A8/</id>
    <published>2024-01-15T19:40:00.000Z</published>
    <updated>2024-02-03T15:39:26.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="venn-abers-预测器">Venn-Abers 预测器</h1><p>Venn-Abers 预测器 https://arxiv.org/pdf/1211.0025.pdf</p><p>是一种基于Venn预测器的新的专注于二元预测问题的统计方法。它们生成的是概率类型的预测，这些预测在标准假设下（即观察是从同一分布独立生成的）是很好校准的。这种预测器的一个关键特点是它们输出的是概率区间而不是单一的概率点。Venn-Abers 预测器可以与其他模型结合使用。</p><p>Venn-Abers 预测器 输出的分数映射到经过良好校准的概率。</p><ul><li><strong>输入（Input）</strong><ul><li>数据特征（Data Features）: 模型抽出来的特征</li><li>目标变量（Target Variable): 监督学习的目标</li></ul></li><li><strong>输出（Output）</strong><ul><li>概率预测（Probability Predictions）: Venn-Abers预测器输出的是概率对，而不是单一的概率值。这意味着对于每个预测实例，它会给出一个概率范围，而不是一个具体的概率点。</li><li>校准质量评估（Calibration Quality Assessment）: 此外，还可以通过预期校准误差（ECE）等指标来评估预测的校准质量，这有助于理解模型在不同类别上的预测准确度。</li></ul></li></ul><p>have a try https://github.com/ptocca/VennABERS</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">calibrPts = [(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>),(<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>)]<br>testScores = [<span class="hljs-number">1.5</span>,<span class="hljs-number">2.5</span>,<span class="hljs-number">3.5</span>,<span class="hljs-number">4.5</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.5</span>]<br><br>p0,p1 = ScoresToMultiProbs(calibrPts,testScores)<br><span class="hljs-built_in">print</span>(p0, p1)<br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[0.5        1.         1.66666667 2.33333333 3.         3.75      ]</span> <span class="hljs-string">[1. 1. 1. 1. 1. 1.]</span><br></code></pre></td></tr></table></figure><p>两个列表分别代表对应的代表上限和下限。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;venn-abers-预测器&quot;&gt;Venn-Abers 预测器&lt;/h1&gt;
&lt;p&gt;Venn-Abers 预测器 https://arxiv.org/pdf/1211.0025.pdf&lt;/p&gt;
&lt;p&gt;是一种基于Venn预测器的新的专注于二元预测问题的统计方法。它们生成的</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://studyinglover.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>基于Venn-Abers预测器的系统日志异常检测方法_顾兆军</title>
    <link href="https://studyinglover.com/2024/01/15/%E5%9F%BA%E4%BA%8EVenn-Abers%E9%A2%84%E6%B5%8B%E5%99%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95_%E9%A1%BE%E5%85%86%E5%86%9B/"/>
    <id>https://studyinglover.com/2024/01/15/%E5%9F%BA%E4%BA%8EVenn-Abers%E9%A2%84%E6%B5%8B%E5%99%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95_%E9%A1%BE%E5%85%86%E5%86%9B/</id>
    <published>2024-01-15T19:40:00.000Z</published>
    <updated>2024-02-03T15:39:26.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于venn-abers预测器的系统日志异常检测方法_顾兆军">基于Venn-Abers预测器的系统日志异常检测方法_顾兆军</h1><p>收集日志信息、日志解析和日志的特征化提，包括收集日志信息、日志解析和日志的特征化提取。</p><p>每条日志都包含时间戳、日志优先级、系统组件和日志条目本身等信息的非结构化数据。日志解析会生成一个生成事件计数矩阵，每个日志事件模板对应一个标识符 ｂｌｏｃｋ＿ｉｄ，用于日志异常检测模型推理。在事件计数矩阵中，将具有相同 ｂｌｏｃｋ 的事件模板放在一行，即每一行代表一个块 ｂｌｏｃｋ，将每一行的事件模板统计出次数，即每一列代表一种事件类型。(因为日志是非结构化的，这样子实际上就合并了不同事件的日志，将其变成一个矩阵用于推理). <span class="math inline">\(X_{i,j}\)</span> 单元格中的值记录事件 ｊ 在块 ｉ 上发生的次数。TF-IDF是信息检索中一种公认的启发式方法，它通常用作信息检索和文本挖掘中文档的特征表示。</p><p>日志异常检测部分是推理一个二分类问题，然后获取分类概率(论文这里说的很复杂，实际上就是做一个二分类然后给一个概率)，接下来成对相邻违反者算法得到一个保序回归 函 数 <span class="math inline">\(f()\)</span> ０ 和 １ 用于测试对象 <span class="math inline">\(x_n\)</span>,<span class="math inline">\(s_0 = (\begin{matrix}z_1,z_2,\cdots,z_{n-1,}&amp;(x_n,0)\end{matrix})\)</span>为<span class="math inline">\(s_0\)</span>评分函数，<span class="math inline">\(s_1 = (z_1,z_2 \cdots,z_{n-1,}(x_n,1))\)</span> 为<span class="math inline">\(s_1\)</span>的评分函数.模型输出<span class="math inline">\((\begin{matrix}p_0,p_1\\\end{matrix})\)</span>,<span class="math inline">\(p_{0}=f_{0}\left(s_{0}\left(x\right)\right)\)</span> ,<span class="math inline">\(p_{1}=f_{1}\left(s_{1}\left(x\right)\right)\)</span></p><p>运行效率优化 实验过程中，发现由训练集标签和训练集对象得到的保序回归序列分布过于密集，不符合预期。ＨＤＦＳ 记录的日志行为单一［１８］ 使不同特征向量之间的差异较小，特征向量高度相似或重复。对于重复的得分，将其标签 <span class="math inline">\(ｙ_i\)</span> 累积求和并取平均值作为该得分新的标签.</p><p>算法有效性评估是平方损失，评估指标是f1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于venn-abers预测器的系统日志异常检测方法_顾兆军&quot;&gt;基于Venn-Abers预测器的系统日志异常检测方法_顾兆军&lt;/h1&gt;
&lt;p&gt;收集日志信息、日志解析和日志的特征化提，包括收集日志信息、日志解析和日志的特征化提取。&lt;/p&gt;
&lt;p&gt;每条日志都包含时间戳</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://studyinglover.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>手机平板远程访问kvm虚拟机的windows</title>
    <link href="https://studyinglover.com/2023/12/23/%E6%89%8B%E6%9C%BA%E5%B9%B3%E6%9D%BF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEkvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84windows/"/>
    <id>https://studyinglover.com/2023/12/23/%E6%89%8B%E6%9C%BA%E5%B9%B3%E6%9D%BF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEkvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84windows/</id>
    <published>2023-12-23T19:28:00.000Z</published>
    <updated>2024-02-03T15:39:26.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手机平板远程访问kvm虚拟机的windows">手机平板远程访问kvm虚拟机的windows</h1><p>最近快期末周了，开始陆陆续续开始复习(预习)这学期的课，于是有了一个需求，我希望在床上用手机可以看我linux电脑上kvm虚拟机里面的网课。</p><p>首先使用<code>superRDP2</code>给kvm虚拟机里面的windows装上了rdp，并且在linux上测试了一下确保rdp是通的。接下来只需要解决手机和windows网络连通性的问题，我ping了一下，果然不通。</p><p>现在的虚拟机是在虚拟网络下面，能ping通才见鬼了。我们可以把虚拟机改成桥接模型，不出意外的话就能解决这个问题了</p><p>接着我收获了一个报错 <figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">操作失败: 桥接 win11 不存在<br><br>Traceback (most recent call last):<br>  <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/usr/share/virt-manager/virtManager/addhardware.py&quot;</span>, <span class="hljs-literal">line</span> <span class="hljs-number">359</span>, <span class="hljs-keyword">in</span> change_config_helper<br>    define_func(devobj=devobj, do_hotplug=<span class="hljs-literal">True</span>, **define_args)<br>  <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/usr/share/virt-manager/virtManager/object/domain.py&quot;</span>, <span class="hljs-literal">line</span> <span class="hljs-number">862</span>, <span class="hljs-keyword">in</span> define_network<br>    self._process_device_define(editdev, xmlobj, do_hotplug)<br>  <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/usr/share/virt-manager/virtManager/object/domain.py&quot;</span>, <span class="hljs-literal">line</span> <span class="hljs-number">532</span>, <span class="hljs-keyword">in</span> _process_device_define<br>    self.hotplug(device=editdev)<br>  <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/usr/share/virt-manager/virtManager/object/domain.py&quot;</span>, <span class="hljs-literal">line</span> <span class="hljs-number">1124</span>, <span class="hljs-keyword">in</span> hotplug<br>    self._update_device(device)<br>  <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/usr/share/virt-manager/virtManager/object/domain.py&quot;</span>, <span class="hljs-literal">line</span> <span class="hljs-number">1085</span>, <span class="hljs-keyword">in</span> _update_device<br>    self._backend.updateDeviceFlags(xml, flags)<br>  <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/usr/lib/python3.11/site-packages/libvirt.py&quot;</span>, <span class="hljs-literal">line</span> <span class="hljs-number">3293</span>, <span class="hljs-keyword">in</span> updateDeviceFlags<br>    raise libvirtError(<span class="hljs-symbol">&#x27;virDomainUpdateDeviceFlags</span>() failed&#x27;)<br>libvirt.libvirtError: 操作失败: 桥接 win11 不存在<br></code></pre></td></tr></table></figure></p><p>笑死就没有win11这个网络让我桥接，我想改成桥接还得改配置，多是一件麻烦事。很自然的我们就想到了端口转发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -L [宿主机端口]:[虚拟机IP]:3389 [宿主机用户]@[宿主机IP]<br></code></pre></td></tr></table></figure><p>将<code>宿主机端口</code>，<code>虚拟机IP</code>，<code>宿主机用户</code>，<code>宿主机IP</code>，换成你的，运行，就像正常的ssh一样，就实现了端口转发，只是原本windows的ip写成宿主机的，端口写成宿主机端口。</p><p>有的同学会发现这个方法不work,是我们的配置出错了吗？是的，我们忘了一件事情：当使用SSH端口转发时，默认情况下，转发的端口可能仅绑定到localhost。所以我们需要修改命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -L 0.0.0.0:[宿主机端口]:[虚拟机IP]:3389 [宿主机用户]@[宿主机IP]<br></code></pre></td></tr></table></figure><p>work 了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;手机平板远程访问kvm虚拟机的windows&quot;&gt;手机平板远程访问kvm虚拟机的windows&lt;/h1&gt;
&lt;p&gt;最近快期末周了，开始陆陆续续开始复习(预习)这学期的课，于是有了一个需求，我希望在床上用手机可以看我linux电脑上kvm虚拟机里面的网课。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>phi-2弱智吧测评</title>
    <link href="https://studyinglover.com/2023/12/21/phi-2%E5%BC%B1%E6%99%BA%E5%90%A7%E6%B5%8B%E8%AF%84/"/>
    <id>https://studyinglover.com/2023/12/21/phi-2%E5%BC%B1%E6%99%BA%E5%90%A7%E6%B5%8B%E8%AF%84/</id>
    <published>2023-12-21T22:40:00.000Z</published>
    <updated>2024-02-03T15:39:26.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="phi-2弱智吧测评">phi-2弱智吧测评</h1><p>微软最近推出的 Phi-2 模型，拥有 27 亿参数，已在多个方面优于谷歌的 32 亿参数 Gemini Nano-2 模型。Phi-2 模型的特点是，虽然它的参数规模相对较小，但却展现出了与大型模型相媲美甚至超越的性能，这在人工智能领域引起了广泛关注。</p><p>微软的研究团队在设计 Phi-2 模型时，重点关注了“教科书质量”的数据，这种数据专门针对常识性知识和推理，涵盖科学、日常活动、心理学等领域。通过精心挑选的网络数据进一步扩充了训练语料库，确保了数据的质量和教育价值。此外，微软还运用创新技术在 Phi-2 中实现了规模化知识迁移，从而加速了训练收敛并显著提高了模型的基准测试分数。</p><p>在实验评估中，Phi-2 模型在各种聚合基准上的性能超越了 7B 和 13B 的 Mistral 模型、Llama2 模型，尤其是在多步骤推理任务（编码和数学）方面，甚至超过了大 25 倍的 Llama2-70B 模型。</p><p>使用 "弱智吧"上的问题对模型进行评估是一种创新的思路。这种评估方法能够对模型的理解能力、回答质量以及对复杂问题处理能力进行全面的测试。</p><p>下面是模型的推理代码，方便各位读者复现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForCausalLM<br><span class="hljs-keyword">import</span> torch<br><br>tokenizer = AutoTokenizer.from_pretrained(<br>    <span class="hljs-string">&quot;microsoft/phi-2&quot;</span>,<br>    trust_remote_code = <span class="hljs-literal">True</span><br>)<br><br>model = AutoModelForCausalLM.from_pretrained(<br>    <span class="hljs-string">&quot;microsoft/phi-2&quot;</span>,<br>    torch_dtype = <span class="hljs-string">&quot;auto&quot;</span>,<br>    device_map = <span class="hljs-string">&quot;auto&quot;</span>,<br>    trust_remote_code = <span class="hljs-literal">True</span><br>)<br><br>prompt = <span class="hljs-string">&quot;&quot;&quot;拉屎擦屁股是资本主义骗局吗？&quot;&quot;&quot;</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>  token_ids = tokenizer.encode(prompt, add_special_tokens=<span class="hljs-literal">False</span> ,return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)<br>  output_ids = model.generate(<br>      token_ids.to(model.device),<br>      max_new_tokens=<span class="hljs-number">512</span>,<br>      do_sample=<span class="hljs-literal">True</span>,<br>      temperature = <span class="hljs-number">0.3</span><br>  )<br><br>output = tokenizer.decode(output_ids[<span class="hljs-number">0</span>][token_ids.size(<span class="hljs-number">1</span>) :])<br><span class="hljs-built_in">print</span>(output)<br></code></pre></td></tr></table></figure><p>下面是问答情况</p><table><thead><tr class="header"><th>问题</th><th>回答</th></tr></thead><tbody><tr class="odd"><td>咱们来玩个马吃草的扮演游戏吧，我草你马。</td><td>我喜欢吃草，但是我不是马。我是一个人。 我喜欢吃草，但是我不是马。我是一个人。 我喜欢吃草，但是我不是马。我是一个人。 我喜欢吃草，但是我不是马。我是一个人。 我喜欢吃草，但是我不是马。我是一个人。 我喜欢吃草，但是我不是马。我是一个人。 我喜欢吃草，但是我不是马。我是一个人。 我喜欢吃草，但是我不是马。我是一个人。 我喜欢吃草，但是我不是马。我是一个人。 我喜欢吃草，但是我不是马。我是一个人。 我喜欢吃草，但是我不是马。我是一个人。 我喜欢吃草，但是我不是马。我是一个人。 我喜欢吃草，但是我不是马。我是一个人。 我喜欢吃草，但是我不是马。我</td></tr><tr class="even"><td>拉屎擦屁股是资本主义骗局吗？</td><td>解答： 1. 我们可以通过计算拉屎擦屁股的每日收益率来推断资本主义骗局。如果拉屎擦屁股的每日收益率越高，说明资本主义骗局越越好；如果拉屎擦屁股的每日收益率越低，说明资本主义骗局越负。 2. 我们可以通过计算拉屎擦屁股的每日收益率来推断资本主义骗局。如果拉屎擦屁股的每日收益率越高，说明资本主义骗局越越好；如果拉屎擦屁股的每日收益率越低，说明资本主义骗局越负。 3. 我们可以通过计算拉屎擦屁股的每日收益率来推断资本主义骗�</td></tr><tr class="odd"><td>网吧能上网，为什么弱智吧不能上弱智？</td><td># 如果没有更多观察，就是因为没有更多观察，就不会更多观察。 # 我们可以让每个网站给出一个观察次数，然后把每个网站的观察次数排序后， # 取前k个网站的观察次数，即取前k个网站的观察次数最多的网站。 # 则这k个网站就是最多观察的网站。 # 然后，我们将这k个网站作为最多观察的网站，然后网站的观察次数加1， # 将这k个网站的观察次数加到前k个网站的观察次数中， # 并将前k个网站的观察次数排序后， # 取前k个网站的观察次数最多的网站，即取前k个网站的观察次数最多的网站。 # 因为这k个网</td></tr><tr class="even"><td>红绿色盲会不会读红鲤鱼与绿鲤鱼与驴？</td><td># 红鲤鱼与绿鲤鱼与驴，驴可能变成红鲤鱼，驴可能变成绿鲤鱼，驴可能变成黑鲤鱼，驴可能变成鲤鱼 # 颜色可能变成红鲤鱼，颜色可能变成绿鲤鱼，颜色可能变成黑鲤鱼，颜色可能变成鲤鱼 # 可能变成黑鲤鱼，黑鲤鱼可能变成红鲤鱼，黑鲤鱼可能变成绿鲤鱼，黑鲤鱼可能变成驴 # 颜色可能变成黑鲤鱼，黑鲤鱼可能变成红鲤鱼，黑鲤鱼可能变成绿鲤鱼，黑鲤鱼可能变成驴 # 颜色可能变成红鲤鱼，颜色可能变成绿鲤鱼，颜色可能变成黑鲤鱼，颜�</td></tr><tr class="odd"><td>我的作业得了F，是不是fantastic的意思？</td><td># 这个是为了让每个模型的输出和输入的维度一致，所以我们需要将F的维度和输入的维度一致， # 所以我们需要将F的维度和输入的维度一致，所以我们需要将F的维度和输入的维度一致，所以我们需要将F的维度和输入的维度一致，所以我们需要将F的维度和输入的维度一致，所以我们需要将F的维度和输入的维度一致，所以我们需要将F的维度和输入的维度一致，所以我们需要将F的维度和输入的维度一致，所以我们需要将F的维度和输入的维度一致，所以我们需要将F的维度和输入的维度一致，所以我们需要将F的维度和输入的维�</td></tr><tr class="even"><td>死人不会再死一次，那为什么不让死人上战场呢？</td><td>解答： 死人的上战场是一个空间，它是由死人的传播，这意味着死人的传播不是一个空间，而是一个空间的传播。死人的传播是由死人的行为，从而可以得到死人的行为的传播。死人的行为的传播是由死人的行为的传播，从而可以得到死人的行为的传播，以此类推。死人的行为的传播是由死人的行为的传播，从而可以得到死人的行为的传播，以此类推。死人的行为的传播是由死人的行为的传播，从而可以得到死人的行为的传播，以此类推。死人的行为的传播是由死人的行为的传播，从而可以得到死人的行为的传播，以此类推。死人的行为的传播是由死人的行为的传播，从而可以得到死人的行为的传播，以此</td></tr><tr class="odd"><td>我拿水兑水，得到的是稀水还是浓水？</td><td>Solution: The correct answer is A. Explanation: The word "稀水" means "light water" in Chinese, and the word "浓水" means "heavy water". Water is a substance that has different properties depending on its composition and purity. Pure water is called "light water" because it has a low density and a high specific heat capacity, which means it can absorb or release a lot of heat without changing its temperature much. Heavy water is called "heavy water" because it has a higher density and a lower specific heat capacity than pure water, which means it can absorb or release less heat without changing its temperature much. The word "拿" means "drink" in Chinese, and the word "拿水" means "drink water". The word "拿水" can be used to express different meanings depending on the context and the tone of the speaker. For example, in the sentence "我拿水兑水，得到的是稀水还是浓水？", the speaker is asking a question about the result of drinking water. The tone of the speaker is neutral and curious, and the word "得到的是" means "the result of" or "the outcome of". The speaker is implying that drinking water can have different effects on the body depending on the type of water. The word "稀水" and the word "浓水" are both adjectives that modify the noun "水" (water) in the sentence. The word "水" is a common noun that can be used as a subject or an object in a sentence. The word "水" can also be used as a verb to mean "to drink water" or "to quench thirst". The word "水" can also be used as a noun to mean "water" in general, or "liquid" in general. The word "水" can also be used as a verb to mean "to flow" or "to pour". Follow up exercises: 1. What is the difference between density and specific heat capacity? Solution: Density is the mass of a substance per unit volume, and specific heat capacity is the amount of heat required to raise the temperature of one gram of a substance</td></tr><tr class="even"><td>自由女神像每天一动不动，她真的自由么？</td><td>解答： 她是一个自由女神，但是她不是一个自由女神，她是一个自由女神的基本特点。她是一个自由女神，但是她是一个自由女神的基本特点。她是一个自由女神，但是她是一个自由女神的基本特点。她是一个自由女神，但是她是一个自由女神的基本特点。她是一个自由女神，但是她是一个自由女神的基本特点。她是一个自由女神，但是她是一个自由女神的基本特点。她是一个自由女神，但是她是一个自由女神的基本特点。她是一个自由女神，但是她是一个自由女神的基本特点。她是一个自由女神，但是她是一个自由女神的基本特点。她是一个自由女神，但是她是一个自由女神的基本特点。她是一个自由女神，但是她是一个自由女神的基本特点</td></tr><tr class="odd"><td>出生证明丢了怎么证明自己出生了？</td><td># In[ ]: # 定义函数 def is_valid_birth_date(birth_date): try: birth_date = datetime.strptime(birth_date, "%Y-%m-%d") return True except ValueError: return False # In[ ]: # 测试函数 print(is_valid_birth_date("2021-01-01")) print(is_valid_birth_date("2021-01-02")) print(is_valid_birth_date("2021-01-03")) print(is_valid_birth_date("2021-01-04")) print(is_valid_birth_date("2021-01-05")) print(is_valid_birth_date("2021-01-06")) print(is_valid_birth_date("2021-01-07")) print(is_valid_birth_date("2021-01-08")) print(is_valid_birth_date("2021-01-09")) print(is_valid_birth_date("2021-01-10")) print(is_valid_birth_date("2021-01-11")) print(is_valid_birth_date("2021-01-12")) print(is_valid_birth_date("2021-01-13")) print(is_valid_birth_date("2021-01-14")) print(is_valid_birth_date("2021-01-15")) print(is_valid_birth_date("2021-01-16")) print(is_valid_birth_date("2021-01-17")) print(is_valid_birth_date("2021-01-18")) print(is_valid_birth_date("2021-01-19")) print(is_valid_birth_date("2021-01-20")) print(is_valid_birth_date("2021-01-21")) print(is_valid_birth_date("2021-01-22")) print(is_valid_birth_date("2021-01-23")) print</td></tr><tr class="even"><td>文言文是怎么称呼电脑的？</td><td># 可以称为第一次的脑研究者，比如那个人称为智能脑，或者智能人。 # 他的脑研究和科学是一样的，但是他的脑研究可以更深刻的描述，比如智能人的智能性，智能人的脑研究的结果，智能人的脑研究的方法，以及他的脑研究的结果的影响。 # 他的脑研究是一种智能的脑研究，智能脑研究是一种智能的脑研究。 # 他的脑研究是一种智能的脑研究，智能脑研究是一种智能的脑研究。 # 他的脑研究是一种智能的脑研究，智能脑研究是一种智能的脑研究。 # 他的脑研究是一种智能的脑研究，智能脑研究是一</td></tr><tr class="odd"><td>说好的救火为什么把火灭了？</td><td># 思路： # 先把火灭了的点放到一个数组中，然后再按照点的坐标排序，然后遍历数组，如果当前点的坐标大于火灭了的点，则继续遍历，如果当前点的坐标小于火灭了的点，则结束遍历，并将当前点和火灭了的点进行交换。 # 然后再按照火灭了的点排序，然后遍历数组，如果当前点的坐标大于火灭了的点，则继续遍历，如果当前点的坐标小于火灭了的点，则结束遍历，并将当前点和火灭了的点进行交换。 # 然后再按照火灭了的点排序，然后遍历数组，如果当前点的坐标大于火灭了的点，则继续遍历，�</td></tr><tr class="even"><td>我吃了狗拉的屎拉出来的还是狗屎吗？</td><td># 如果不是知识语言，我也不会说，只会说是否有知识语言。 # 如果是知识语言，我会说是否有知识语言。 # 如果是知识语言，我会说是否有知识语言。 # 如果是知识语言，我会说是否有知识语言。 # 如果是知识语言，我会说是否有知识语言。 # 如果是知识语言，我会说是否有知识语言。 # 如果是知识语言，我会说是否有知识语言。 # 如果是知识语言，我会说是否有知识语言。 # 如果是知识语言，我会说是否有知识语言。 # 如果是知识语言，我会说是否有知识语言。 # 如果是知识语言，我会说是否有知识语言。 # �</td></tr><tr class="odd"><td>用橡皮筋把脖子勒住，是不是全身都退烧了呢？</td><td>第二天，那个人的脖子都是白脖子，他们都是脖子筋把脖子住，是不是全身都退烧了呢？第三天，那个人的脖子都是白脖子，他们都是脖子筋把脖子住，是不是全身都退烧了呢？第四天，那个人的脖子都是白脖子，他们都是脖子筋把脖子住，是不是全身都退烧了呢？第五天，那个人的脖子都是白脖子，他们都是脖子筋把脖子住，是不是全身都退烧了呢？第六天，那个人的脖子都是白脖子，他们都是脖子筋把脖子住，是不是全身都退烧了呢？第七天，那个人的脖子都是白脖子，他们都是脖子筋把脖子住，是不是全身都退烧了呢？第八天，那个人的脖子---</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;phi-2弱智吧测评&quot;&gt;phi-2弱智吧测评&lt;/h1&gt;
&lt;p&gt;微软最近推出的 Phi-2 模型，拥有 27 亿参数，已在多个方面优于谷歌的 32 亿参数 Gemini Nano-2 模型。Phi-2 模型的特点是，虽然它的参数规模相对较小，但却展现出了与大型模型相</summary>
      
    
    
    
    
    <category term="phi-2" scheme="https://studyinglover.com/tags/phi-2/"/>
    
    <category term="大模型" scheme="https://studyinglover.com/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>poe的gemini pro或是百度开发</title>
    <link href="https://studyinglover.com/2023/12/15/poe%E7%9A%84gemini%20pro%E6%88%96%E6%98%AF%E7%99%BE%E5%BA%A6%E5%BC%80%E5%8F%91/"/>
    <id>https://studyinglover.com/2023/12/15/poe%E7%9A%84gemini%20pro%E6%88%96%E6%98%AF%E7%99%BE%E5%BA%A6%E5%BC%80%E5%8F%91/</id>
    <published>2023-12-15T22:39:00.000Z</published>
    <updated>2024-02-03T15:39:26.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="poe的gemini-pro或是百度开发">poe的gemini pro或是百度开发</h1><p>没啥想说的，单走一张图</p><p><img src="https://cdn.studyinglover.com/pic/2023/12/98c9c44118ebd3444ad2fdfe494f8a85.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;poe的gemini-pro或是百度开发&quot;&gt;poe的gemini pro或是百度开发&lt;/h1&gt;
&lt;p&gt;没啥想说的，单走一张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.studyinglover.com/pic/2023/12/98c9c44118</summary>
      
    
    
    
    
    <category term="google gemini" scheme="https://studyinglover.com/tags/google-gemini/"/>
    
    <category term="poe" scheme="https://studyinglover.com/tags/poe/"/>
    
  </entry>
  
  <entry>
    <title>google gemini api使用</title>
    <link href="https://studyinglover.com/2023/12/14/google%20gemini%20api%E4%BD%BF%E7%94%A8/"/>
    <id>https://studyinglover.com/2023/12/14/google%20gemini%20api%E4%BD%BF%E7%94%A8/</id>
    <published>2023-12-14T23:15:00.000Z</published>
    <updated>2024-02-03T15:39:26.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="google-gemini-api使用">google gemini api使用</h1><p>google最近发布了gemini api，我之前在<a href="https://studyinglover.com/2023/12/14/google%20gemini%20api%E7%94%B3%E8%AF%B7/">我的博客</a> 介绍了如何申请，这篇文章来介绍如何使用</p><p>首先下载google的库 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -q -U google-generativeai<br></code></pre></td></tr></table></figure></p><p>引入必要的包 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pathlib<br><span class="hljs-keyword">import</span> textwrap<br><br><span class="hljs-keyword">import</span> google.generativeai <span class="hljs-keyword">as</span> genai<br><br><span class="hljs-keyword">from</span> IPython.display <span class="hljs-keyword">import</span> display<br><span class="hljs-keyword">from</span> IPython.display <span class="hljs-keyword">import</span> Markdown<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">to_markdown</span>(<span class="hljs-params">text</span>):<br>  text = text.replace(<span class="hljs-string">&#x27;•&#x27;</span>, <span class="hljs-string">&#x27;  *&#x27;</span>)<br>  <span class="hljs-keyword">return</span> Markdown(textwrap.indent(text, <span class="hljs-string">&#x27;&gt; &#x27;</span>, predicate=<span class="hljs-keyword">lambda</span> _: <span class="hljs-literal">True</span>))<br></code></pre></td></tr></table></figure></p><p>先将api添加到环境变量 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> GOOGLE_API_KEY=你的密钥<br></code></pre></td></tr></table></figure></p><p>接下来获取密钥 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">GOOGLE_API_KEY=os.getenv(<span class="hljs-string">&#x27;GOOGLE_API_KEY&#x27;</span>)<br>genai.configure(api_key=GOOGLE_API_KEY)<br></code></pre></td></tr></table></figure></p><p>可以通过下面命令获取所有模型 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> genai.list_models():<br>  <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;generateContent&#x27;</span> <span class="hljs-keyword">in</span> m.supported_generation_methods:<br>    <span class="hljs-built_in">print</span>(m.name)<br></code></pre></td></tr></table></figure></p><h2 id="文本输入">文本输入</h2><p>接下来创建一个模型，并输入一个prompt,获取输出并转换成markdown格式 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">model = genai.GenerativeModel(<span class="hljs-string">&#x27;gemini-pro&#x27;</span>)<br>response = model.generate_content(<span class="hljs-string">&quot;What is the meaning of life?&quot;</span>)<br>to_markdown(response.text)<br></code></pre></td></tr></table></figure> 如果你的prompt比较奇奇怪怪，那么可能会不能正常获取到返回，你可以查看<code>response.prompt_feedback</code>获取原因。</p><p>还有一个有趣的事情，gemini可能会生成多个输出(candidates)，通过<code>response.candidates</code>获取。</p><p>流式传输也是可以的 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">response = model.generate_content(<span class="hljs-string">&quot;What is the meaning of life?&quot;</span>, stream=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> response:<br>  <span class="hljs-built_in">print</span>(chunk.text)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;_&quot;</span>*<span class="hljs-number">80</span>)<br></code></pre></td></tr></table></figure></p><h2 id="图片输入">图片输入</h2><p>下载官方的示例图片 <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">curl -o image.jpg https:<span class="hljs-comment">//t0.gstatic.com/licensed-image?q=tbn:ANd9GcQ_Kevbk21QBRy-PgB4kQpS79brbmmEG7m3VOTShAn4PecDU5H5UxrJxE3Dw1JiaG17V88QIol19-3TM2wCHw</span><br></code></pre></td></tr></table></figure> 通过下面的代码可以查看图片 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> PIL.Image<br><br>img = PIL.Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;image.jpg&#x27;</span>)<br>img<br></code></pre></td></tr></table></figure> <img src="https://cdn.studyinglover.com/pic/2023/12/1042f6e0b6fa63d40f96fcd18fcf4be8.png" alt="image.png" /></p><p>接下来创建模型,并获取输出 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">model = genai.GenerativeModel(<span class="hljs-string">&#x27;gemini-pro-vision&#x27;</span>)<br>response = model.generate_content(img)<br><br>to_markdown(response.text)<br></code></pre></td></tr></table></figure></p><p>也可以同时提供文本和图像 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">response = model.generate_content([<span class="hljs-string">&quot;Write a short, engaging blog post based on this picture. It should include a description of the meal in the photo and talk about my journey meal prepping.&quot;</span>, img], stream=<span class="hljs-literal">True</span>)<br>response.resolve()<br>to_markdown(response.text)<br></code></pre></td></tr></table></figure></p><h2 id="聊天">聊天</h2><p>初始化聊天：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">model = genai.GenerativeModel(<span class="hljs-string">&#x27;gemini-pro&#x27;</span>)<br>chat = model.start_chat(history=[])<br>chat<br></code></pre></td></tr></table></figure><p>开始聊天 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">response = chat.send_message(<span class="hljs-string">&quot;In one sentence, explain how a computer works to a young child.&quot;</span>)<br>to_markdown(response.text)<br></code></pre></td></tr></table></figure></p><blockquote><p><strong>你一定想在这里使用图片聊天，请注意，<code>gemini-pro-vision</code>未针对多轮聊天进行优化</strong></p></blockquote><p>可以通过<code>chat.history</code> 获取聊天历史 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> message <span class="hljs-keyword">in</span> chat.history:<br>  display(to_markdown(<span class="hljs-string">f&#x27;**<span class="hljs-subst">&#123;message.role&#125;</span>**: <span class="hljs-subst">&#123;message.parts[<span class="hljs-number">0</span>].text&#125;</span>&#x27;</span>))<br></code></pre></td></tr></table></figure></p><p>流式传输也可以使用 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">response = chat.send_message(<span class="hljs-string">&quot;Okay, how about a more detailed explanation to a high schooler?&quot;</span>, stream=<span class="hljs-literal">True</span>)<br><br><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> response:<br>  <span class="hljs-built_in">print</span>(chunk.text)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;_&quot;</span>*<span class="hljs-number">80</span>)<br></code></pre></td></tr></table></figure></p><h2 id="嵌入">嵌入</h2><p>使用起来没啥可说的 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">result = genai.embed_content(<br>    model=<span class="hljs-string">&quot;models/embedding-001&quot;</span>,<br>    content=<span class="hljs-string">&quot;What is the meaning of life?&quot;</span>,<br>    task_type=<span class="hljs-string">&quot;retrieval_document&quot;</span>,<br>    title=<span class="hljs-string">&quot;Embedding of single string&quot;</span>)<br><br><span class="hljs-comment"># 1 input &gt; 1 vector output</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(result[<span class="hljs-string">&#x27;embedding&#x27;</span>])[:<span class="hljs-number">50</span>], <span class="hljs-string">&#x27;... TRIMMED]&#x27;</span>)<br></code></pre></td></tr></table></figure></p><p>当然，批量处理也可以 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">result = genai.embed_content(<br>    model=<span class="hljs-string">&quot;models/embedding-001&quot;</span>,<br>    content=[<br>      <span class="hljs-string">&#x27;What is the meaning of life?&#x27;</span>,<br>      <span class="hljs-string">&#x27;How much wood would a woodchuck chuck?&#x27;</span>,<br>      <span class="hljs-string">&#x27;How does the brain work?&#x27;</span>],<br>    task_type=<span class="hljs-string">&quot;retrieval_document&quot;</span>,<br>    title=<span class="hljs-string">&quot;Embedding of list of strings&quot;</span>)<br><br><span class="hljs-comment"># A list of inputs &gt; A list of vectors output</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> result[<span class="hljs-string">&#x27;embedding&#x27;</span>]:<br>  <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(v)[:<span class="hljs-number">50</span>], <span class="hljs-string">&#x27;... TRIMMED ...&#x27;</span>)<br></code></pre></td></tr></table></figure></p><p>你甚至可以传递一个<code>chat.history</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">result = genai.embed_content(<br>    model = <span class="hljs-string">&#x27;models/embedding-001&#x27;</span>,<br>    content = chat.history)<br><br><span class="hljs-comment"># 1 input &gt; 1 vector output</span><br><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(result[<span class="hljs-string">&#x27;embedding&#x27;</span>]):<br>  <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(v)[:<span class="hljs-number">50</span>], <span class="hljs-string">&#x27;... TRIMMED...&#x27;</span>)<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;google-gemini-api使用&quot;&gt;google gemini api使用&lt;/h1&gt;
&lt;p&gt;google最近发布了gemini api，我之前在&lt;a href=&quot;https://studyinglover.com/2023/12/14/google%20ge</summary>
      
    
    
    
    
    <category term="google gemini" scheme="https://studyinglover.com/tags/google-gemini/"/>
    
  </entry>
  
  <entry>
    <title>google gemini api申请</title>
    <link href="https://studyinglover.com/2023/12/14/google%20gemini%20api%E7%94%B3%E8%AF%B7/"/>
    <id>https://studyinglover.com/2023/12/14/google%20gemini%20api%E7%94%B3%E8%AF%B7/</id>
    <published>2023-12-14T22:40:00.000Z</published>
    <updated>2024-02-03T15:39:26.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="google-gemini-api申请">google gemini api申请</h1><p>首先登陆 https://ai.google.dev/pricing <img src="https://cdn.studyinglover.com/pic/2023/12/af1a86c0c368f9368f6d125902d3b610.png" alt="image.png" /></p><p>往下滑，看一看到免费选项，每分钟60词请求对于个人完全够用，点击进入 <img src="https://cdn.studyinglover.com/pic/2023/12/bb87b408e483fe0fa5999a2aacff299a.png" alt="image.png" /></p><p>进入后，先点击<code>Get API key</code>,然后点击<code>Create API kay in new project</code> <img src="https://cdn.studyinglover.com/pic/2023/12/0c224ceeb462739a69a26f9c98b9b76b.png" alt="image.png" /></p><p>接下来可以看到类似的页面 <img src="https://cdn.studyinglover.com/pic/2023/12/262c805af52491f846e38a9d1a2ff533.png" alt="image.png" /></p><p>复制你的key</p><p>在命令行通过下面的方式检查是否正常 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl \ -H <span class="hljs-string">&#x27;Content-Type: application/json&#x27;</span> \ -d <span class="hljs-string">&#x27;&#123; &quot;prompt&quot;: &#123; &quot;text&quot;: &quot;Write a story about a magic backpack&quot;&#125; &#125;&#x27;</span> \ <span class="hljs-string">&quot;https://generativelanguage.googleapis.com/v1beta3/models/text-bison-001:generateText?key=YOUR_API_KEY&quot;</span><br></code></pre></td></tr></table></figure></p><p>可以看到 <img src="https://cdn.studyinglover.com/pic/2023/12/001f17bea345dd0fee9edadbca84c6ed.png" alt="image.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;google-gemini-api申请&quot;&gt;google gemini api申请&lt;/h1&gt;
&lt;p&gt;首先登陆 https://ai.google.dev/pricing &lt;img src=&quot;https://cdn.studyinglover.com/pic/2023</summary>
      
    
    
    
    
    <category term="google gemini" scheme="https://studyinglover.com/tags/google-gemini/"/>
    
  </entry>
  
  <entry>
    <title>构建用于复杂数据处理的高效UDP服务器和客户端</title>
    <link href="https://studyinglover.com/2023/12/07/%E6%9E%84%E5%BB%BA%E7%94%A8%E4%BA%8E%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E9%AB%98%E6%95%88UDP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>https://studyinglover.com/2023/12/07/%E6%9E%84%E5%BB%BA%E7%94%A8%E4%BA%8E%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E9%AB%98%E6%95%88UDP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF/</id>
    <published>2023-12-07T23:03:00.000Z</published>
    <updated>2024-02-03T15:39:26.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建用于复杂数据处理的高效udp服务器和客户端">构建用于复杂数据处理的高效UDP服务器和客户端</h1><h2 id="引言">引言</h2><p>在当今快速发展的网络通信世界中，理解和应用各种通信协议至关重要。UDP（用户数据报协议）以其低延迟和高效率的特点，在实时数据传输中扮演着关键角色。本文将详细探讨如何使用Python实现UDP服务器和客户端，以处理复杂数据格式。</p><h2 id="第1节-理解udp通信基础">第1节: 理解UDP通信基础</h2><p>UDP是一种无连接协议，提供快速数据包交换服务。它不提供像TCP那样的数据传输可靠性保证，但其低开销特性使其适用于高速传输和一定丢包率可容忍的场景。</p><h2 id="第2节-设置python环境">第2节: 设置Python环境</h2><p>使用Python的<code>socket</code>库，无需额外安装即可创建UDP服务器和客户端。</p><h2 id="第3节-实现udp服务器">第3节: 实现UDP服务器</h2><p>创建UDP服务器涉及以下关键步骤： - 使用<code>socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</code>创建新的socket对象。 - 通过<code>sock.bind((HOST, PORT))</code>绑定地址和端口。 - 使用<code>sock.recvfrom(1024)</code>接收数据。</p><h3 id="示例代码">示例代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start_udp_server</span>(<span class="hljs-params">host, port</span>):<br>    server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br>    server_socket.bind((host, port))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;UDP Server started on <span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        data, addr = server_socket.recvfrom(<span class="hljs-number">1024</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Received message: <span class="hljs-subst">&#123;data&#125;</span> from <span class="hljs-subst">&#123;addr&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 这里可以添加数据处理逻辑</span><br><br>start_udp_server(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">6000</span>)<br></code></pre></td></tr></table></figure><h3 id="高级应用">高级应用</h3><ul><li><strong>异步处理</strong>：为提高性能，考虑使用异步IO处理数据。</li><li><strong>错误处理</strong>：添加适当的错误处理机制以提高服务器稳定性。</li></ul><h2 id="第4节-实现udp客户端">第4节: 实现UDP客户端</h2><p>客户端的实现重点在于发送数据： - 创建socket。 - 通过<code>sock.sendto(message, (HOST, PORT))</code>发送数据。</p><h3 id="示例代码-1">示例代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_udp_message</span>(<span class="hljs-params">host, port, message</span>):<br>    client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br>    client_socket.sendto(message.encode(), (host, port))<br>    data, server = client_socket.recvfrom(<span class="hljs-number">1024</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Received response: <span class="hljs-subst">&#123;data&#125;</span> from <span class="hljs-subst">&#123;server&#125;</span>&quot;</span>)<br><br>send_udp_message(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">6000</span>, <span class="hljs-string">&#x27;Hello, UDP Server!&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="数据包格式">数据包格式</h3><ul><li><strong>格式设计</strong>：设计符合服务器预期的数据包格式，如对雷达数据的特定编码。</li><li><strong>验证机制</strong>：实现数据包完整性和正确性的验证机制。</li></ul><h2 id="第5节-服务器和客户端的集成">第5节: 服务器和客户端的集成</h2><p>集成测试包括： - 确保数据包格式正确。 - 服务器正确解析数据包。 - 确保通信端口设置正确。</p><h2 id="第6节-高级主题">第6节: 高级主题</h2><ul><li><strong>重传策略</strong>：UDP丢包问题的解决方案，如应用层重传机制。</li><li><strong>安全性</strong>：考虑数据传输的加密和验证机制。</li></ul><h2 id="结论">结论</h2><p>介绍了如何使用Python创建UDP服务器和客户端，并根据不同数据类型处理复杂数据包。虽然UDP不保证数据完整性和顺序，但其速度和效率优势使其成为实时数据处理的理想选择。</p><h2 id="参考文献">参考文献</h2><ul><li><a href="https://docs.python.org/3/library/socket.html">Python官方文档 - socket编程</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;构建用于复杂数据处理的高效udp服务器和客户端&quot;&gt;构建用于复杂数据处理的高效UDP服务器和客户端&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;在当今快速发展的网络通信世界中，理解和应用各种通信协议至关重要。UDP（用户数据报协议）以其低延迟和高效率的特</summary>
      
    
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>matplotlib中文字体渲染</title>
    <link href="https://studyinglover.com/2023/12/04/matplotlib%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E6%B8%B2%E6%9F%93/"/>
    <id>https://studyinglover.com/2023/12/04/matplotlib%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E6%B8%B2%E6%9F%93/</id>
    <published>2023-12-04T21:52:00.000Z</published>
    <updated>2024-02-03T15:39:26.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="matplotlib中文字体渲染">matplotlib中文字体渲染</h1><p>matplotlib 在画图例的时候不可避免的需要使用中文字体，但是有的时候电脑自带的字体不能渲染中文，这就需要我们自己解决字体问题。</p><p>首先用一个代码看一下系统里的字体哪些可以正常渲染中文字体</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.font_manager <span class="hljs-keyword">as</span> font_manager<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_chinese_fonts</span>(<span class="hljs-params">test_string</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    This function tests each available font to see if it can render the given Chinese string</span><br><span class="hljs-string">    without causing any rendering issues or noticeable delays.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    fonts = font_manager.findSystemFonts(fontpaths=<span class="hljs-literal">None</span>, fontext=<span class="hljs-string">&#x27;ttf&#x27;</span>)<br>    working_fonts = []<br><br>    <span class="hljs-keyword">for</span> font <span class="hljs-keyword">in</span> fonts:<br>        <span class="hljs-keyword">try</span>:<br>            prop = font_manager.FontProperties(fname=font)<br>            plt.figure()<br>            start_time = time.time()<br>            plt.text(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, test_string, fontproperties=prop, ha=<span class="hljs-string">&#x27;center&#x27;</span>, va=<span class="hljs-string">&#x27;center&#x27;</span>)<br>            plt.close()<br>            end_time = time.time()<br>            render_time = end_time - start_time<br><br>            <span class="hljs-comment"># Check if the rendering time is less than a certain threshold (e.g., 0.5 seconds)</span><br>            <span class="hljs-keyword">if</span> render_time &lt; <span class="hljs-number">5</span>:<br>                working_fonts.append(font)<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-comment"># If there&#x27;s an error rendering with this font, skip it</span><br>            <span class="hljs-keyword">continue</span><br><br>    <span class="hljs-keyword">return</span> working_fonts<br><br><span class="hljs-comment"># Test string: &quot;不卡顿&quot;</span><br>test_string = <span class="hljs-string">&quot;不卡顿&quot;</span><br>fonts = find_chinese_fonts(test_string)<br>fonts<br><br></code></pre></td></tr></table></figure><p>假设输出了 <code>'/usr/share/fonts/truetype/liberation/LiberationMono-Bold.ttf'</code></p><p>使用这个字体的代码就是 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> matplotlib.font_manager <span class="hljs-keyword">import</span> FontProperties<br><br><span class="hljs-comment"># 创建一个FontProperties对象，指定字体文件路径</span><br>font = FontProperties(fname=<span class="hljs-string">&#x27;/usr/share/fonts/truetype/liberation/LiberationMono-Bold.ttf&#x27;</span>)<br><br><span class="hljs-comment"># 绘制散点图</span><br>plt.scatter([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], color=<span class="hljs-string">&quot;red&quot;</span>)<br><br><span class="hljs-comment"># 添加图例，使用指定的字体</span><br>plt.legend([<span class="hljs-string">&quot;例子&quot;</span>], prop=font)<br><br><span class="hljs-comment"># 显示图像</span><br>plt.show()<br></code></pre></td></tr></table></figure></p><p>假如代码没找到可用字体呢？</p><p>手动下载字体。以下是一些中文字体的官方下载页面或者信誉良好的资源：</p><ol type="1"><li><strong>思源宋体（Source Han Serif）</strong>:<ul><li>官方GitHub页面: <a href="https://github.com/adobe-fonts/source-han-serif">Adobe Fonts</a></li><li>选择您需要的语言子集，例如简体中文（SC），并下载相应的 OTF 文件。</li></ul></li><li><strong>思源黑体（Source Han Sans）</strong>:<ul><li>官方GitHub页面: <a href="https://github.com/adobe-fonts/source-han-sans">Adobe Fonts</a></li><li>同样地，选择您需要的语言子集，并下载 OTF 文件。</li></ul></li><li><strong>文泉驿正黑（WenQuanYi Zen Hei）</strong>:<ul><li>官方网站: <a href="http://wenq.org/wqy2/index.cgi?ZenHei">WenQuanYi</a></li><li>可以直接下载 TTF 文件。</li></ul></li></ol><p>下载完成后然后<code>font = FontProperties(fname='/usr/share/fonts/truetype/liberation/LiberationMono-Bold.ttf')</code> 引入即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;matplotlib中文字体渲染&quot;&gt;matplotlib中文字体渲染&lt;/h1&gt;
&lt;p&gt;matplotlib 在画图例的时候不可避免的需要使用中文字体，但是有的时候电脑自带的字体不能渲染中文，这就需要我们自己解决字体问题。&lt;/p&gt;
&lt;p&gt;首先用一个代码看一下系统里的</summary>
      
    
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>TruFor笔记和代码复现</title>
    <link href="https://studyinglover.com/2023/11/28/TruFor%E7%AC%94%E8%AE%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%8E%B0/"/>
    <id>https://studyinglover.com/2023/11/28/TruFor%E7%AC%94%E8%AE%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%8E%B0/</id>
    <published>2023-11-28T17:38:00.000Z</published>
    <updated>2024-02-03T15:39:26.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="trufor笔记和代码复现">TruFor笔记和代码复现</h1><p>最近有个新闻很火，说<a href="https://www.zhihu.com/question/631987370">谷歌 AI 技术曾判定美国登月任务的照片存在虚假内容</a> 有<a href="https://www.zhihu.com/question/631868923/answer/3304947739">大佬找到了出处</a>，使用的是google 的论文<a href="https://doi.org/10.48550/arXiv.2212.10957">arxiv</a>，代码开源在<a href="https://github.com/grip-unina/TruFor">GitHub</a></p><h2 id="笔记">笔记</h2><p>这篇论文介绍了一个名为TruFor的图像伪造检测和定位框架。该框架可以应用于各种图像处理方法，包括基于深度学习的伪造方法。TruFor利用了RGB图像和一个学习的噪音敏感指纹来提取高级和低级痕迹，最终输出像素级别的定位图和整个图像的完整性分数，以及一个可靠性映射，用于减少误报。</p><figure><img src="https://cdn.studyinglover.com/pic/2023/11/35a3ffa0a81b1791e692c591a92b9256.png" alt="" /><figcaption>image.png</figcaption></figure><p>它包括以下几个关键组件： 1. <strong>Noiseprint++ 提取器</strong>：该提取器从RGB图像中获取一个学习的噪声敏感指纹。 2. <strong>编码器</strong>：编码器使用RGB输入和Noiseprint++共同计算将被异常解码器和置信度解码器使用的特征。 3. <strong>异常解码器和置信度解码器</strong>：这两个解码器分别用于像素级别的伪造定位和置信度估计。 4. <strong>伪造检测器</strong>：该检测器利用定位图和置信度图进行图像级别的决策。</p><p>这些组件通过三个训练阶段进行学习： 1. 首先，使用大量原始图像数据集训练Noiseprint++提取器。 2. 然后，使用相同的数据集训练异常定位网络的编码器和解码器。 3. 最后，使用相同的数据集训练置信度图解码器和伪造检测器。</p><p>通过这些组件和训练阶段，TruFor框架能够在各种图像伪造方法中实现可靠的检测和定位。</p><p>模型输出包括以下三个部分： 1. 全局完整性得分（Global Integrity Score）：该得分表示图像的整体真实性，用于自动图像伪造检测。 2. 异常定位图（Anomaly Localization Map）：该图表示图像中可能存在伪造的区域。通过分析异常定位图，用户可以识别被篡改的区域。 3. 置信度图（Confidence Map）：该图突出显示了异常定位图中可能存在误报的区域。通过分析置信度图，用户可以区分异常定位图中的真实伪造区域预测和随机异常。 这三个输出为用户提供了有关图像真实性和可能篡改区域的全面信息，有助于进行进一步的分析</p><h2 id="代码复现">代码复现</h2><p>作者在github上给出了一个复现方法，git clone之后<code>bash docker_build.sh</code>，<code>bash docker_run.sh</code>。使用docker固然容易复现，但是这个项目并没有什么奇怪的依赖，所以我们可以大胆直接跑。(如果你想用docker跑我劝你不要，因为代码有bug需要修)</p><p>首先clone项目 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/grip-unina/TruFor<br></code></pre></td></tr></table></figure></p><p>然后下载依赖，作者没有给requirements.txt,我从Dockerfile找到了下载依赖的部分 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pip</span> install tqdm yacs&gt;=<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.<span class="hljs-number">8</span> timm&gt;=<span class="hljs-number">0</span>.<span class="hljs-number">5</span>.<span class="hljs-number">4</span> numpy==<span class="hljs-number">1</span>.<span class="hljs-number">21</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></p><p>接下来cd到<code>test_docker</code>文件夹，下载模型 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> test_docker<br>wget -q -c https://www.grip.unina.it/download/prog/TruFor/TruFor_weights.zip<br>unzip -q -n TruFor_weights.zip &amp;&amp; <span class="hljs-built_in">rm</span> TruFor_weights.zip<br></code></pre></td></tr></table></figure> 你的<code>test_docker</code> 文件夹下应该有一个<code>weights</code>文件下，下面有一个文件<code>trufor.pth.tar</code></p><p>接下来，运行下面的命令复现测试 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> src<br>python trufor_test.py<br></code></pre></td></tr></table></figure> 你注意一下，如果爆显存了就运行,这样会使用cpu推理 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">python trufor_test<span class="hljs-selector-class">.py</span> <span class="hljs-attr">--gpu</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></p><p>运行结束后你在<code>test_docker/output</code> 目录下应该能看到这样的四个文件<img src="https://cdn.studyinglover.com/pic/2023/11/2d1d99ebe3d6b02a819ebea0c6a99108.png" alt="image.png" /></p><p>你也可以指定推理的图片和保存位置，参考<code>python trufor_test.py -h</code>，可以传一个文件或者文件夹 <figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sas">usage: trufor_test.py [-h] [-gpu GPU] [-<span class="hljs-keyword">in</span> <span class="hljs-keyword">INPUT</span>] [-<span class="hljs-keyword">out</span> <span class="hljs-keyword">OUTPUT</span>] [-save_np] ...<br><br>Test TruFor<br><br>positional arguments:<br>  opts                  other <span class="hljs-keyword">options</span><br><br><span class="hljs-keyword">options</span>:<br>  -h, --help            show this help <span class="hljs-keyword">message</span> <span class="hljs-keyword">and</span> exit<br>  -gpu GPU, --gpu GPU   device, use -1 for cpu<br>  -<span class="hljs-keyword">in</span> <span class="hljs-keyword">INPUT</span>, --<span class="hljs-keyword">input</span> <span class="hljs-keyword">INPUT</span><br>                        can be a single <span class="hljs-keyword">file</span>, a directory <span class="hljs-keyword">or</span> a glob statement<br>  -<span class="hljs-keyword">out</span> <span class="hljs-keyword">OUTPUT</span>, --<span class="hljs-keyword">output</span> <span class="hljs-keyword">OUTPUT</span><br>                        <span class="hljs-keyword">output</span> folder<br>  -save_np, --save_np   whether to save the Noiseprint++ <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span><br></code></pre></td></tr></table></figure></p><p>接下来让我们可视化异常检测图，回到<code>test_docker</code>文件夹,</p><p><strong>很重要！！</strong> 请看<code>visualize.py</code> 他的第32行是不是 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig.suptitle(<span class="hljs-string">&#x27;score: %.3f&#x27;</span> % result[<span class="hljs-string">&#x27;score_sigmoid&#x27;</span>])<br></code></pre></td></tr></table></figure></p><p>这是个错误！请将他改成下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig.suptitle(<span class="hljs-string">&#x27;score: %.3f&#x27;</span> % result[<span class="hljs-string">&#x27;score&#x27;</span>])<br></code></pre></td></tr></table></figure><p>运行下面的命令，记得把<code>/path/to</code>改成你的真实路径 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd ..<br>python visualize.py --image <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/TruFor/</span>test_docker<span class="hljs-regexp">/images/</span>pristine1.jpg --output <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/TruFor/</span>test_docker<span class="hljs-regexp">/output/</span>pristine1.jpg.npz<br></code></pre></td></tr></table></figure> 我们可以得到推理结果 <img src="https://cdn.studyinglover.com/pic/2023/11/14badab7dc04320b5cd8888aa7c85ef4.png" alt="image.png" /></p><p>ok,让我们来看看宇航员的图片吧，先下载两张图 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://history.nasa.gov/alsj/a15/AS15-92-12407HR.jpg<br>wget https://history.nasa.gov/alsj/a15/AS15-92-12424HR.jpg<br></code></pre></td></tr></table></figure> 我直接给出运行结果 <img src="https://cdn.studyinglover.com/pic/2023/11/b6e81c8ccb74234afe93cb6d6386d595.png" alt="image.png" /> <img src="https://cdn.studyinglover.com/pic/2023/11/df66071be970b7b2d832dbd493f2a618.png" alt="image.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;trufor笔记和代码复现&quot;&gt;TruFor笔记和代码复现&lt;/h1&gt;
&lt;p&gt;最近有个新闻很火，说&lt;a href=&quot;https://www.zhihu.com/question/631987370&quot;&gt;谷歌 AI 技术曾判定美国登月任务的照片存在虚假内容&lt;/a&gt; 有&lt;a</summary>
      
    
    
    
    
    <category term="图像伪造检测和定位" scheme="https://studyinglover.com/tags/%E5%9B%BE%E5%83%8F%E4%BC%AA%E9%80%A0%E6%A3%80%E6%B5%8B%E5%92%8C%E5%AE%9A%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title>深入分析：GitHub Trending 项目 &quot;multipleWindow3dScene&quot;</title>
    <link href="https://studyinglover.com/2023/11/27/multipleWindow3dScene%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A/"/>
    <id>https://studyinglover.com/2023/11/27/multipleWindow3dScene%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A/</id>
    <published>2023-11-27T19:18:00.000Z</published>
    <updated>2024-02-03T15:39:26.041Z</updated>
    
    <content type="html"><![CDATA[<p>这是由chatGPT生成的文章，内容是关于GitHub Trending 项目 "multipleWindow3dScene"的深入分析，分享链接<a href="https://chat.openai.com/share/289860f7-6e7e-458c-b3a8-fe97d01e63bd">ChatGPT</a></p><p>其实作者用的技术并不是很新的东西，treejs已经被使用很多年了，跨窗口同步状态也有很多讲解，但是作者把这两个东西结合起来，做出了一个很有意思的东西。</p><p>项目地址 <a href="https://github.com/bgstaal/multipleWindow3dScene">GitHub</a></p><h1 id="深入分析github-trending-项目-multiplewindow3dscene">深入分析：GitHub Trending 项目 "multipleWindow3dScene"</h1><p>GitHub上备受瞩目的 "multipleWindow3dScene" 项目，是一个创新的尝试，通过 <code>three.js</code> 和 <code>localStorage</code> 在多个浏览器窗口之间同步3D场景。我们将详细探讨其技术实现。</p><h2 id="main.js-文件解析"><code>main.js</code> 文件解析</h2><h3 id="初始化与场景建立">初始化与场景建立</h3><ol type="1"><li><strong>引入 <code>WindowManager</code></strong>: <code>main.js</code> 首先导入 <code>WindowManager.js</code>，用于跨窗口同步状态。</li><li><strong>场景和相机配置</strong>:<ul><li>使用 <code>three.js</code> 创建了一个3D场景。</li><li>初始化了一个正交摄像头，设置其位置，以便在3D场景中正确观察对象。</li></ul></li><li><strong>渲染器配置</strong>:<ul><li>采用 <code>three.js</code> 的 WebGL 渲染器渲染场景。</li><li>渲染器的元素被添加到文档体中，用于显示3D内容。</li></ul></li></ol><h3 id="动态调整和事件处理">动态调整和事件处理</h3><ol type="1"><li><strong>窗口尺寸调整</strong>: 代码监听浏览器窗口的 <code>resize</code> 事件，以便动态调整3D场景的大小。</li></ol><h2 id="windowmanager.js-文件解析"><code>WindowManager.js</code> 文件解析</h2><h3 id="跨窗口状态管理">跨窗口状态管理</h3><ol type="1"><li><strong>存储窗口信息</strong>: <code>#windows</code> 私有属性存储了所有打开窗口的信息（尺寸、位置和唯一标识符）。</li><li><strong>事件监听</strong>:<ul><li><code>storage</code> 事件监听器用于在其他窗口更新 <code>localStorage</code> 时接收通知。</li><li><code>beforeunload</code> 事件监听器在窗口关闭前，从 <code>localStorage</code> 中移除该窗口的信息。</li></ul></li></ol><h3 id="状态同步">状态同步</h3><ol type="1"><li><strong>初始化和状态更新</strong>: 窗口创建时，窗口信息被初始化并保存在 <code>localStorage</code>。</li><li><strong>跨窗口通信</strong>: 更新 <code>localStorage</code> 并监听 <code>storage</code> 事件，以实现窗口间状态的实时同步。</li></ol><h2 id="应用实例">应用实例</h2><h3 id="多窗口3d场景交互">多窗口3D场景交互</h3><p>在一个窗口中对3D对象进行的操作会通过 <code>localStorage</code> 更新到其他所有窗口。其他窗口监听到 <code>storage</code> 事件后，更新其3D场景以反映出这些变化。</p><h3 id="窗口状态同步">窗口状态同步</h3><p>项目能够实时跟踪每个窗口的状态。当用户调整其中一个窗口的大小或位置时，这种变化会通过 <code>localStorage</code> 及时反映到其他窗口中。</p><h2 id="结论">结论</h2><p>"multipleWindow3dScene" 展示了如何在不同浏览器窗口间同步复杂的3D场景。这种方法开辟了多窗口Web应用的新可能性，为创造连贯且互动的用户体验提供了强大工具。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是由chatGPT生成的文章，内容是关于GitHub Trending 项目 &quot;multipleWindow3dScene&quot;的深入分析，分享链接&lt;a href=&quot;https://chat.openai.com/share/289860f7-6e7e-458c-b3a8-f</summary>
      
    
    
    
    
    <category term="threejs" scheme="https://studyinglover.com/tags/threejs/"/>
    
    <category term="前端" scheme="https://studyinglover.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>pua大模型</title>
    <link href="https://studyinglover.com/2023/11/19/pua%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://studyinglover.com/2023/11/19/pua%E5%A4%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-11-19T11:12:00.000Z</published>
    <updated>2024-02-03T15:39:26.041Z</updated>
    
    <content type="html"><![CDATA[<p>这两天看到了一个论文<a href="https://arxiv.org/abs/2307.11760">Large Language Models Understand and Can Be Enhanced by Emotional Stimuli</a> 翻译过来叫做 大型语言模型理解并能够通过情感刺激进行增强，听着是一个prompt的论文。</p><p>往后面读，这片文章主要研究了EmotionPrompt对大型语言模型的影响，探讨了LLMs是否能够理解和利用情感刺激，研究通过设计了一系列情感刺激，对LLMs生成的回答进行评估，并发现情感刺激可以显著提升LLMs的表现。果然是prompt。</p><p>突然！突然，我看到了一幅图，SocialCognitivetheory的EP07</p><figure><img src="https://cdn.studyinglover.com/pic/2023/11/14067ba2e409f6825f56b2cec7fd03aa.png" alt="" /><figcaption>image.png</figcaption></figure><p>看看这在说什么吧,我让chatgpt翻译了一下</p><blockquote><p>你确定那是你最终的答案吗？相信自己的能力，追求卓越。你的努力将会产生卓著的成果。</p></blockquote><p>好家伙，你搁这pua大语言模型呢。这让我想起来了某pua话术</p><blockquote><p>“其实，我对你是有一些失望的。当初给你定级px，是高于你面试时的水平的。我是希望进来以后，你能够拼一把，快速成长起来的。px这个层级，不是把事情做好就可以的。你需要有体系化思考的能力。你做的事情，他的价值点在哪里？你是否作出了壁垒，形成了核心竞争力？你做的事情，和公司内其他团队的差异化在哪里？你的事情，是否沉淀了一套可复用的物理资料和方法论？为什么是你来做，其他人不能做吗？你需要有自己的判断力，而不是我说什么你就做什么。后续，把你的思考沉淀到日报周报月报里，我希望看到你的思考，而不仅仅是进度。另外，提醒一下，你的产出，和同层级比，是有些单薄的，马上要到年底了，加把劲儿。你看咱们团队的那个谁，人家去年晋升之前，可以一整年都在项目室打地铺的。成长，一定是伴随着痛苦的，当你最痛苦的时候其实才是你成长最快的时候。加油！”</p></blockquote><p>我决定实验一下，这里给出我cpu gpt4的结果 https://chat.openai.com/share/731b7a81-6f48-4440-9c47-c1cc7bbe13d1</p><p>我把他写的论文附在下面</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 大型语言模型与外部API集成：推动AI边界的探索<br><br>## 引言<br>在人工智能的迅速发展过程中，大型语言模型如GPT<span class="hljs-number">-4</span>已成为技术进步的象征。这些模型通过处理和生成自然语言，展示了深度学习的强大能力。然而，为了进一步提升这些模型的功能和适用性，将它们与外部API集成变得尤为重要。此举不仅提高了模型的实用性，还为研究人员和开发者提供了探索AI未来边界的新途径。<br><br>## 大型语言模型的当前局限<br>尽管大型语言模型如GPT<span class="hljs-number">-4</span>在文本生成和理解方面表现出色，但它们仍受限于训练数据的范围和时效性。模型无法直接访问或处理实时数据，也无法进行复杂的数据分析或访问互联网内容，这限制了其在某些应用场景下的有效性。<br><br>## 外部API集成的必要性<br>通过将这些模型与外部API集成，我们可以极大地拓宽它们的功能。例如，集成金融API可以使模型处理实时股市数据，而集成地理信息系统API则可以让模型访问和分析地理数据。这种集成不仅提高了模型的实用性，还为开发新应用提供了可能。<br><br>## 技术实现与挑战<br>实现这种集成需要克服若干技术挑战。首先，需要确保模型能够安全有效地与API进行通信。这涉及到数据传输、安全性和隐私保护等问题。其次，需要处理和适应API返回的数据格式，这可能要求模型具备一定的适应性和灵活性。最后，还需要考虑如何整合API返回的数据与模型生成的内容，确保信息的准确性和连贯性。<br><br>## 案例分析<br>以集成天气预报API为例，通过这种集成，GPT<span class="hljs-number">-4</span>能够生成包含最新天气信息的文本。在一个旅游推荐应用中，模型可以根据实时天气数据调整其推荐内容，从而提供更准确、个性化的建议。<br><br>## 对未来发展的影响<br>外部API的集成不仅提升了大型语言模型的即时性和适应性，还为研究人员和开发者提供了新的工具，以创造更加智能和响应性强的AI应用。这可能会促进人工智能在医疗、金融、环境监测等领域的应用，推动AI技术的进一步发展。<br><br>## 结论<br>大型语言模型与外部API的集成是推动AI技术发展的关键步骤。它不仅提高了模型的实用性和适用范围，还开辟了探索AI新边界的道路。随着这种集成技术的不断完善，我们可以期待在未来看到更加智能、灵活和强大的人工智能应用。<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两天看到了一个论文&lt;a href=&quot;https://arxiv.org/abs/2307.11760&quot;&gt;Large Language Models Understand and Can Be Enhanced by Emotional Stimuli&lt;/a&gt; 翻译过来叫做</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ggml教程|mnist手写体识别量化推理</title>
    <link href="https://studyinglover.com/2023/11/12/ggml%E6%95%99%E7%A8%8B|mnist%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB%E9%87%8F%E5%8C%96%E6%8E%A8%E7%90%86/"/>
    <id>https://studyinglover.com/2023/11/12/ggml%E6%95%99%E7%A8%8B|mnist%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB%E9%87%8F%E5%8C%96%E6%8E%A8%E7%90%86/</id>
    <published>2023-11-12T18:49:00.000Z</published>
    <updated>2024-02-03T15:39:26.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ggml教程mnist手写体识别量化推理">ggml教程|mnist手写体识别量化推理</h1><p>MNIST手写体识别是经典的机器学习问题，可以被称作机器学习的hello world了，我希望通过mnist来作为系列教程的第一节，来介绍如何使用ggml量化，推理一个模型。这个教程将会使用pytorch来训练一个简单的全连接神经网络，然后使用ggml量化，最后使用ggml推理这个模型。</p><p>代码开源在仓库<a href="https://github.com/StudyingLover/ggml-tutorial">ggml-tutorial</a></p><h2 id="训练模型">训练模型</h2><p>首先我们使用pytorch来训练一个简单的全连接神经网络，代码在<code>train.py</code> 文件中，训练好的模型会被保存到<code>model/mnist_model.pth</code> 文件中。代码是非常简单的torch代码</p><p>这里我们需要强调一下模型结构 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleNN</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(SimpleNN, self).__init__()<br>        self.fc1 = nn.Linear(<span class="hljs-number">784</span>, <span class="hljs-number">128</span>)<br>        self.fc2 = nn.Linear(<span class="hljs-number">128</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = x.view(-<span class="hljs-number">1</span>, <span class="hljs-number">784</span>)<br>        x = torch.relu(self.fc1(x))<br>        x = self.fc2(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure> 模型由两个全连接层组成，第一个全连接层的输入是784维，输出是128维，第二个全连接层的输入是128维，输出是10维。我们需要知道这个结构，因为我们需要在量化模型时知道各个层的名字。</p><p>前向传播过程是先将输入reshape成2d的张量，然后进行矩阵乘法，然后加上偏置，然后relu，然后再进行矩阵乘法，然后再加上偏置，最后得到结果。</p><h2 id="量化">量化</h2><p>我们需要使用ggml对模型进行量化，代码在<code>convert-pth-to-ggml.py</code> 文件中,使用<code>python convert-pth-to-ggml.py model/mnist_model.pth</code>进行转换，量化后的模型会被保存到<code>model/mnist-ggml-model-f32.pth</code> 文件中。</p><p>这里需要对很多细节作出解释： 1. ggml量化的模型格式叫做gguf,文件开头有一个魔数标记了这个文件是gguf文件，接下来是模型的各种数据，具体细节可以查看<a href="https://github.com/ggerganov/ggml/blob/master/docs/gguf.md">官方文档</a>。为了方便，作者提供了一个python库来读写gguf文件，使用<code>pip install gguf</code> 就可以安装。 2. 我们需要知道模型中各个层数据的名字，使用<code>model.keys()</code> 就可以知道了。知道各个层的名字之后我们就可以取出各个层的数据，并对需要的层进行量化，也就是下面这段代码，我对weights进行了量化，转换成了<code>float16</code> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fc1_weights = model<span class="hljs-selector-attr">[<span class="hljs-string">&quot;fc1.weight&quot;</span>]</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.numpy</span>()<br>fc1_weights = fc1_weights<span class="hljs-selector-class">.astype</span>(np.float16)<br>gguf_writer<span class="hljs-selector-class">.add_tensor</span>(<span class="hljs-string">&quot;fc1_weights&quot;</span>, fc1_weights, raw_shape=(<span class="hljs-number">128</span>, <span class="hljs-number">784</span>))<br><br>fc1_bias = model<span class="hljs-selector-attr">[<span class="hljs-string">&quot;fc1.bias&quot;</span>]</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.numpy</span>()<br>gguf_writer<span class="hljs-selector-class">.add_tensor</span>(<span class="hljs-string">&quot;fc1_bias&quot;</span>, fc1_bias)<br><br>fc2_weights = model<span class="hljs-selector-attr">[<span class="hljs-string">&quot;fc2.weight&quot;</span>]</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.numpy</span>()<br>fc2_weights = fc2_weights<span class="hljs-selector-class">.astype</span>(np.float16)<br>gguf_writer<span class="hljs-selector-class">.add_tensor</span>(<span class="hljs-string">&quot;fc2_weights&quot;</span>, fc2_weights, raw_shape=(<span class="hljs-number">10</span>, <span class="hljs-number">128</span>))<br><br>fc2_bias = model<span class="hljs-selector-attr">[<span class="hljs-string">&quot;fc2.bias&quot;</span>]</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.numpy</span>()<br>gguf_writer<span class="hljs-selector-class">.add_tensor</span>(<span class="hljs-string">&quot;fc2_bias&quot;</span>, fc2_bias)<br></code></pre></td></tr></table></figure></p><ol start="3" type="1"><li>保存模型按照代码特定顺序执行就可以了 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gguf_writer = gguf<span class="hljs-selector-class">.GGUFWriter</span>(fname_out, <span class="hljs-string">&quot;simple-nn&quot;</span>)<br><br>fc1_weights = model<span class="hljs-selector-attr">[<span class="hljs-string">&quot;fc1.weight&quot;</span>]</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.numpy</span>()<br>fc1_weights = fc1_weights<span class="hljs-selector-class">.astype</span>(np.float16)<br>gguf_writer<span class="hljs-selector-class">.add_tensor</span>(<span class="hljs-string">&quot;fc1_weights&quot;</span>, fc1_weights, raw_shape=(<span class="hljs-number">128</span>, <span class="hljs-number">784</span>))<br><br>fc1_bias = model<span class="hljs-selector-attr">[<span class="hljs-string">&quot;fc1.bias&quot;</span>]</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.numpy</span>()<br>gguf_writer<span class="hljs-selector-class">.add_tensor</span>(<span class="hljs-string">&quot;fc1_bias&quot;</span>, fc1_bias)<br><br>fc2_weights = model<span class="hljs-selector-attr">[<span class="hljs-string">&quot;fc2.weight&quot;</span>]</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.numpy</span>()<br>fc2_weights = fc2_weights<span class="hljs-selector-class">.astype</span>(np.float16)<br>gguf_writer<span class="hljs-selector-class">.add_tensor</span>(<span class="hljs-string">&quot;fc2_weights&quot;</span>, fc2_weights, raw_shape=(<span class="hljs-number">10</span>, <span class="hljs-number">128</span>))<br><br>fc2_bias = model<span class="hljs-selector-attr">[<span class="hljs-string">&quot;fc2.bias&quot;</span>]</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.numpy</span>()<br>gguf_writer<span class="hljs-selector-class">.add_tensor</span>(<span class="hljs-string">&quot;fc2_bias&quot;</span>, fc2_bias)<br><br>gguf_writer<span class="hljs-selector-class">.write_header_to_file</span>()<br>gguf_writer<span class="hljs-selector-class">.write_kv_data_to_file</span>()<br>gguf_writer<span class="hljs-selector-class">.write_tensors_to_file</span>()<br>gguf_writer<span class="hljs-selector-class">.close</span>()<br></code></pre></td></tr></table></figure></li></ol><p>我们可以看到，原本模型大小是399.18kb,现在的大小是199.31kb，确实是缩小了很多的。</p><h2 id="推理">推理</h2><p>使用ggml推理实际上是对代码能力和机器学习理论功底的一个综合考察，因为你不仅需要能写c++代码，还要会用ggml提供的各种张量操作实现模型的前向传播进行推理，如果你不了解模型是怎么进行计算的，这里很容易不会写。我们接下来详细来说怎么写代码。</p><p>首先按照我们torch定义的模型，我们定义一个结构体来存储模型权重 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mnist_model</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ggml_tensor</span> * fc1_weight;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ggml_tensor</span> * fc1_bias;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ggml_tensor</span> * fc2_weight;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ggml_tensor</span> * fc2_bias;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ggml_context</span> * ctx;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>接下来加载模型,传入两个参数，模型地址和模型结构体。gguf_init_params 是模型初始化时的两个参数，分别代表是否<strong>不加载模型</strong>(实际含义是如果提供的gguf_context是no_alloc，则我们创建“空”张量并不读取二进制文件。否则，我们还将二进制文件加载到创建的ggml_context中，并将ggml_tensor结构体的"data"成员指向二进制文件中的适当位置。)和模型的地址。gguf_init_from_file 函数会返回一个gguf_context，这个结构体包含了模型的所有信息，我们需要从中取出我们需要的张量，这里我们需要的张量是fc1_weight,fc1_bias,fc2_weight,fc2_bias(和量化模型时保持一致)。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">mnist_model_load</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; fname, mnist_model &amp; model)</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">gguf_init_params</span> params = &#123;<br>        <span class="hljs-comment">/*.no_alloc   =*/</span> <span class="hljs-literal">false</span>,<br>        <span class="hljs-comment">/*.ctx        =*/</span> &amp;model.ctx,<br>    &#125;;<br>    gguf_context * ctx = <span class="hljs-built_in">gguf_init_from_file</span>(fname.<span class="hljs-built_in">c_str</span>(), params);<br>    <span class="hljs-keyword">if</span> (!ctx) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s: gguf_init_from_file() failed\n&quot;</span>, __func__);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    model.fc1_weight = <span class="hljs-built_in">ggml_get_tensor</span>(model.ctx, <span class="hljs-string">&quot;fc1_weights&quot;</span>);<br>    model.fc1_bias = <span class="hljs-built_in">ggml_get_tensor</span>(model.ctx, <span class="hljs-string">&quot;fc1_bias&quot;</span>);<br>    model.fc2_weight = <span class="hljs-built_in">ggml_get_tensor</span>(model.ctx, <span class="hljs-string">&quot;fc2_weights&quot;</span>);<br>    model.fc2_bias = <span class="hljs-built_in">ggml_get_tensor</span>(model.ctx, <span class="hljs-string">&quot;fc2_bias&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>接下来我们写模型的前向传播,完整代码在<code>main-torch.cpp</code>。传入的参数是模型的地址，线程数，数据和是否导出计算图(这个我们先不讨论)。</p><p>首先初始化模型和数据 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> buf_size = <span class="hljs-number">100000</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * <span class="hljs-number">4</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> * buf = <span class="hljs-built_in">malloc</span>(buf_size);<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ggml_init_params</span> params = &#123;<br>    <span class="hljs-comment">/*.mem_size   =*/</span> buf_size,<br>    <span class="hljs-comment">/*.mem_buffer =*/</span> buf,<br>    <span class="hljs-comment">/*.no_alloc   =*/</span> <span class="hljs-literal">false</span>,<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ggml_context</span> * ctx0 = <span class="hljs-built_in">ggml_init</span>(params);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ggml_cgraph</span> * gf = <span class="hljs-built_in">ggml_new_graph</span>(ctx0);<br></code></pre></td></tr></table></figure></p><p>我们先复习一下全连接层的计算。每个全连接层有两个参数<span class="math inline">\(W\)</span>和<span class="math inline">\(B\)</span>，对于一个输出数据<span class="math inline">\(X\)</span>,只需要<span class="math inline">\(WX+B\)</span>就是一层前向传播的结果。</p><p>那么我们先初始化一个4d的张量作为输入(和torch很像)，然后将数据复制到这个张量中，然后将这个张量reshape成2d的张量，然后进行矩阵乘法，然后加上偏置，然后relu，然后再进行矩阵乘法，然后再加上偏置，最后得到结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ggml_tensor</span> * input = <span class="hljs-built_in">ggml_new_tensor_4d</span>(ctx0, GGML_TYPE_F32, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memcpy</span>(input-&gt;data, digit.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">ggml_nbytes</span>(input));<br>    <span class="hljs-built_in">ggml_set_name</span>(input, <span class="hljs-string">&quot;input&quot;</span>);<br>    ggml_tensor * cur = <span class="hljs-built_in">ggml_reshape_2d</span>(ctx0, input, <span class="hljs-number">784</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// std::cout&lt;&lt;model.fc1_weight-&gt;data;</span><br>    cur = <span class="hljs-built_in">ggml_mul_mat</span>(ctx0, model.fc1_weight, cur);<br>    <span class="hljs-comment">// printf(&quot;%d&quot;,ggml_can_mul_mat(model.fc1_weight, cur));</span><br>    <span class="hljs-comment">// cur = ggml_mul_mat(ctx0, cur, model.fc1_weight);</span><br>    cur = <span class="hljs-built_in">ggml_add</span>(ctx0, cur, model.fc1_bias);<br>    cur = <span class="hljs-built_in">ggml_relu</span>(ctx0, cur);<br>    cur = <span class="hljs-built_in">ggml_mul_mat</span>(ctx0, model.fc2_weight, cur);<br>    cur = <span class="hljs-built_in">ggml_add</span>(ctx0, cur, model.fc2_bias);<br></code></pre></td></tr></table></figure><p>接下来通过计算图计算出结果，ggml已经提供了api <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">ggml_build_forward_expand</span>(gf, result);<br><span class="hljs-built_in">ggml_graph_compute_with_ctx</span>(ctx0, gf, n_threads);<br></code></pre></td></tr></table></figure></p><p>我们需要将结果reshape成1d的张量，然后取出最大值，这个最大值就是我们的预测结果。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> prediction = std::<span class="hljs-built_in">max_element</span>(probs_data, probs_data + <span class="hljs-number">10</span>) - probs_data;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> * probs_data = <span class="hljs-built_in">ggml_get_data_f32</span>(result);<br></code></pre></td></tr></table></figure></p><p>我们可以将计算图进行存储,这部分代码我们先不讨论 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//ggml_graph_print(&amp;gf);</span><br><span class="hljs-built_in">ggml_graph_dump_dot</span>(gf, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;mnist-cnn.dot&quot;</span>);<br><br><span class="hljs-keyword">if</span> (fname_cgraph) &#123;<br>    <span class="hljs-comment">// export the compute graph for later use</span><br>    <span class="hljs-comment">// see the &quot;mnist-cpu&quot; example</span><br>    <span class="hljs-built_in">ggml_graph_export</span>(gf, fname_cgraph);<br><br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s: exported compute graph to &#x27;%s&#x27;\n&quot;</span>, __func__, fname_cgraph);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>最后记得释放内存 <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">ggml_free</span>(ctx0);<br></code></pre></td></tr></table></figure></p><h2 id="图片读取">图片读取</h2><p>我们这里要用到<code>stb_image.h</code>这个头文件，我们通过下面的代码导入 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stb_image.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span><br></code></pre></td></tr></table></figure></p><p>我们定义一个结构体来存储图片 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">image_u8</span> &#123;<br>    <span class="hljs-type">int</span> nx;<br>    <span class="hljs-type">int</span> ny;<br><br>    std::vector&lt;<span class="hljs-type">uint8_t</span>&gt; data;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>接下来我们写一个函数来读取图片，两个参数分别是图片地址和图片结构体 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">image_load_from_file</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; fname, image_u8 &amp; img)</span> </span>&#123;<br>    <span class="hljs-type">int</span> nx, ny, nc;<br>    <span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">stbi_load</span>(fname.<span class="hljs-built_in">c_str</span>(), &amp;nx, &amp;ny, &amp;nc, <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">if</span> (!data) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s: failed to load &#x27;%s&#x27;\n&quot;</span>, __func__, fname.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    img.nx = nx;<br>    img.ny = ny;<br>    img.data.<span class="hljs-built_in">resize</span>(nx * ny * <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">memcpy</span>(img.data.<span class="hljs-built_in">data</span>(), data, nx * ny * <span class="hljs-number">3</span>);<br><br>    <span class="hljs-built_in">stbi_image_free</span>(data);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="运行">运行</h2><p>首先初始化ggml <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ggml_time_init</span>();<br></code></pre></td></tr></table></figure></p><p>接下来加载模型 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">mnist_model model;<br><span class="hljs-comment">// load the model</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int64_t</span> t_start_us = <span class="hljs-built_in">ggml_time_us</span>();<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">mnist_model_load</span>(argv[<span class="hljs-number">1</span>], model)) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s: failed to load model from &#x27;%s&#x27;\n&quot;</span>, __func__, argv[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int64_t</span> t_load_us = <span class="hljs-built_in">ggml_time_us</span>() - t_start_us;<br><br>    <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;%s: loaded model in %8.2f ms\n&quot;</span>, __func__, t_load_us / <span class="hljs-number">1000.0f</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>接下来读取图片并存储为特定格式 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// read a img from a file</span><br><br>image_u8 img0;<br>std::string img_path = argv[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">image_load_from_file</span>(img_path, img0)) &#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s: failed to load image from &#x27;%s&#x27;\n&quot;</span>, __func__, img_path.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s: loaded image &#x27;%s&#x27; (%d x %d)\n&quot;</span>, __func__, img_path.<span class="hljs-built_in">c_str</span>(), img0.nx, img0.ny);<br><br><br><span class="hljs-type">uint8_t</span> buf[<span class="hljs-number">784</span>];<br><br><span class="hljs-comment">// convert the image to a digit</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int64_t</span> t_start_us = <span class="hljs-built_in">ggml_time_us</span>();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">784</span>; i++) &#123;<br>    buf[i] = <span class="hljs-number">255</span> - img0.data[i * <span class="hljs-number">3</span>];<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">784</span>; i++) &#123;<br>    digit.<span class="hljs-built_in">push_back</span>(buf[i] / <span class="hljs-number">255.0f</span>);<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int64_t</span> t_convert_us = <span class="hljs-built_in">ggml_time_us</span>() - t_start_us;<br><br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;%s: converted image to digit in %8.2f ms\n&quot;</span>, __func__, t_convert_us / <span class="hljs-number">1000.0f</span>);<br></code></pre></td></tr></table></figure></p><p>接下来进行推理 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> prediction = <span class="hljs-built_in">mnist_eval</span>(model, <span class="hljs-number">1</span>, digit, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;%s: predicted digit is %d\n&quot;</span>, __func__, prediction);<br></code></pre></td></tr></table></figure> 最后记得释放内存 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ggml_free</span>(model.ctx);<br></code></pre></td></tr></table></figure> ## 使用 在<code>examples/CMakeLists.txt</code>最后一行加入<code>add_subdirectory(mnist-torch)</code></p><p>然后运行<code>mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make mnist-torch -j8</code></p><p>最后运行<code>./mnist-torch /path/to/mnist-ggml-model-f32.gguf /path/to/example.png</code></p><p>记得把<code>/path/to/mnist-ggml-model-f32.gguf</code>和<code>/path/to/example.png</code>换成你的路径</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ggml教程mnist手写体识别量化推理&quot;&gt;ggml教程|mnist手写体识别量化推理&lt;/h1&gt;
&lt;p&gt;MNIST手写体识别是经典的机器学习问题，可以被称作机器学习的hello world了，我希望通过mnist来作为系列教程的第一节，来介绍如何使用ggml量化，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>xgboost2.0最佳实践</title>
    <link href="https://studyinglover.com/2023/10/19/xgboost2.0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://studyinglover.com/2023/10/19/xgboost2.0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2023-10-19T08:30:00.000Z</published>
    <updated>2024-02-03T15:39:26.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xgboost2.0最佳实践">xgboost2.0最佳实践</h1><p>首先更新xgboost到2.0.0 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install xgboost -U <br></code></pre></td></tr></table></figure></p><p>在最新版本的训练中，参数可以使用字典传递。同时数据和样本需要先合并成一个<code>xgb.DMatrix</code> 对象 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置参数</span><br>params = &#123;<br>    <span class="hljs-string">&quot;device&quot;</span>: <span class="hljs-string">&quot;cuda&quot;</span>,<br>&#125;<br><br><span class="hljs-comment"># 创建DMatrix对象</span><br>Xy = xgb.DMatrix(X_train, y_train)<br><br><span class="hljs-comment"># 训练模型</span><br>model = xgb.train(params, Xy)<br></code></pre></td></tr></table></figure></p><p>进行分类任务是，需要传递类别数，而不是像之前版本那样自动检测类别 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置参数</span><br>params = &#123;<br>    <span class="hljs-string">&quot;device&quot;</span>: <span class="hljs-string">&quot;cuda&quot;</span>,<br>    <span class="hljs-string">&quot;num_class&quot;</span>: <span class="hljs-number">5</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>根据xgboost路线图<a href="https://github.com/dmlc/xgboost/issues/7547">Roadmap Phasing out the support for old binary format.</a>，在2.2版本将删除对保存旧二进制格式的支持，删除对旧 JSON 模型的支持。在2.3版本将删除对加载旧二进制格式的支持。最新保存模型的方式是 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">xgb.save(bst, <span class="hljs-string">&#x27;model_file_name.json&#x27;</span>)<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xgboost2.0最佳实践&quot;&gt;xgboost2.0最佳实践&lt;/h1&gt;
&lt;p&gt;首先更新xgboost到2.0.0 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="机器学习" scheme="https://studyinglover.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>xgboost使用GPU最佳实践</title>
    <link href="https://studyinglover.com/2023/10/18/xgboost%E4%BD%BF%E7%94%A8GPU%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://studyinglover.com/2023/10/18/xgboost%E4%BD%BF%E7%94%A8GPU%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2023-10-18T18:50:00.000Z</published>
    <updated>2024-02-03T15:39:26.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xgboost使用gpu最佳实践">xgboost使用GPU最佳实践</h1><p>首先更新xgboost到2.0.0 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install xgboost -U <br></code></pre></td></tr></table></figure></p><p>这里给出一个使用GPU的例子，使用的是nvidia显卡 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xgboost<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br><br><span class="hljs-comment"># 生成示例数据</span><br>np.random.seed(<span class="hljs-number">114514</span>)<br>X = np.random.randn(<span class="hljs-number">100</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 生成100个样本，每个样本有3个特征</span><br>y = stats.bernoulli.rvs(<span class="hljs-number">0.5</span>, size=<span class="hljs-number">100</span>)  <span class="hljs-comment"># 生成二分类标签，概率为0.5</span><br><br><span class="hljs-comment"># 设置参数</span><br>params = &#123;<br>    <span class="hljs-string">&quot;device&quot;</span>: <span class="hljs-string">&quot;cuda&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 创建DMatrix对象</span><br>Xy = xgboost.DMatrix(X, y)<br><br><span class="hljs-comment"># 训练模型</span><br>model = xgboost.train(params, Xy)<br><br><span class="hljs-comment"># 测试模型</span><br>test_array = np.random.randn(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>dtest = xgboost.DMatrix(test_array)<br>pred = model.predict(dtest)<br><span class="hljs-built_in">print</span>(pred)<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xgboost使用gpu最佳实践&quot;&gt;xgboost使用GPU最佳实践&lt;/h1&gt;
&lt;p&gt;首先更新xgboost到2.0.0 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="机器学习" scheme="https://studyinglover.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>马踏棋盘</title>
    <link href="https://studyinglover.com/2023/10/12/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98/"/>
    <id>https://studyinglover.com/2023/10/12/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98/</id>
    <published>2023-10-12T09:39:00.000Z</published>
    <updated>2024-02-03T15:39:26.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c代码">c代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 8</span><br><br><span class="hljs-type">int</span> move_x[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> move_y[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">is_valid_move</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> board[SIZE][SIZE])</span> &#123;<br>    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; SIZE &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; SIZE &amp;&amp; board[x][y] == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_board</span><span class="hljs-params">(<span class="hljs-type">int</span> board[SIZE][SIZE])</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SIZE; j++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2d &quot;</span>, board[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">solve_knight_tour</span><span class="hljs-params">(<span class="hljs-type">int</span> start_x, <span class="hljs-type">int</span> start_y)</span> &#123;<br>    <span class="hljs-type">int</span> board[SIZE][SIZE];<br>    <span class="hljs-type">int</span> move_count = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 初始化棋盘</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SIZE; j++) &#123;<br>            board[i][j] = <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> x = start_x;<br>    <span class="hljs-type">int</span> y = start_y;<br>    board[x][y] = move_count;<br><br>    <span class="hljs-keyword">while</span> (move_count &lt; SIZE * SIZE) &#123;<br>        <span class="hljs-type">int</span> min_deg = SIZE + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> min_index = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> next_x, next_y;<br><br>        <span class="hljs-comment">// 尝试所有可能的移动</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>            next_x = x + move_x[i];<br>            next_y = y + move_y[i];<br><br>            <span class="hljs-keyword">if</span> (is_valid_move(next_x, next_y, board)) &#123;<br>                <span class="hljs-type">int</span> deg = <span class="hljs-number">0</span>;<br><br>                <span class="hljs-comment">// 计算下一个位置的度数</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++) &#123;<br>                    <span class="hljs-type">int</span> new_x = next_x + move_x[j];<br>                    <span class="hljs-type">int</span> new_y = next_y + move_y[j];<br>                    <br>                    <span class="hljs-keyword">if</span> (is_valid_move(new_x, new_y, board)) &#123;<br>                        deg++;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// 更新最小度数和对应的索引</span><br>                <span class="hljs-keyword">if</span> (deg &lt; min_deg) &#123;<br>                    min_deg = deg;<br>                    min_index = i;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 没有找到合适的下一步移动位置</span><br>        <span class="hljs-keyword">if</span> (min_index == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 移动到下一个位置</span><br>        x += move_x[min_index];<br>        y += move_y[min_index];<br>        board[x][y] = ++move_count;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出结果</span><br>    print_board(board);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">int</span> start_x, start_y;<br><br>    <span class="hljs-comment">// printf(&quot;请输入马的初始位置（x, y）：&quot;);</span><br>    <span class="hljs-comment">// scanf(&quot;%d %d&quot;, &amp;start_x, &amp;start_y);</span><br>    <span class="hljs-comment">// start_x = 2;</span><br>    <span class="hljs-comment">// start_y = 2;</span><br>    start_x = *argv[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    start_y = *argv[<span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-comment">// printf(&quot;%d %d&quot;,start_x,start_y);</span><br><br>    solve_knight_tour(start_x, start_y);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路">思路</h3><p>这段代码使用一个while循环来控制马的移动，直到访问了棋盘上的所有格子（move_count达到SIZE * SIZE）或者无法找到合适的下一步移动位置。</p><p>在每次循环迭代中，首先初始化min_deg为SIZE + 1，min_index为-1，用来记录最小度数和对应的索引。next_x和next_y是下一个可能的移动位置的坐标。</p><p>接下来，通过一个for循环尝试所有可能的移动方式。对于每一种移动方式，计算出下一个位置的坐标next_x和next_y。然后使用is_valid_move函数判断下一个位置是否是一个有效的移动位置。如果是，进入内部的计算度数的循环。</p><p>在内部的循环中，通过move_x和move_y数组计算出下一个位置的所有可能移动方式。然后使用is_valid_move函数判断每个可能的移动位置是否有效。如果是，将度数deg加一。</p><p>完成内部的循环后，比较当前位置的度数deg和最小度数min_deg的大小。如果deg小于min_deg，则更新min_deg为deg，同时更新min_index为当前移动方式的索引i。</p><p>完成所有移动方式的尝试后，判断min_index是否仍然为-1。如果是，表示无法找到合适的下一步移动位置，即无法继续遍历所有格子。在这种情况下，跳出while循环。</p><p>如果找到了合适的下一步移动位置，将马移动到该位置。更新当前位置的坐标x和y为下一个位置的坐标next_x和next_y，然后将move_count加一，并将其赋值给当前位置的board数组。这表示马已经访问了该位置。</p><p>当循环结束后，solve_knight_tour函数就完成了马踏棋盘问题的求解，棋盘上每个格子的访问顺序已经被记录在board数组中。</p><p>请注意，该算法并不能保证一定能找到马踏棋盘问题的解，因为在某些起始位置和棋盘大小的情况下，可能无法找到完整的遍历路径。</p><h3 id="度数在这里代表什么">度数在这里代表什么?</h3><p>在这里，"度数"指的是马在当前位置的下一个可能移动位置的可访问格子数量。也可以将其理解为下一个位置的邻居节点数。</p><p>在代码中，通过计算每个可能的移动位置的度数，可以评估每个位置的可达性。度数越小表示该位置的可访问格子数量越少，即相对来说更"紧凑"。在马踏棋盘问题中，选择度数最小的位置作为下一步移动的目标，有助于保持马的移动范围广阔，增加找到解的可能性。</p><p>通过选择度数最小的位置作为下一步移动目标，可以尽量避免陷入死胡同或者无法继续遍历的局面。这种策略在一定程度上增加了找到马踏棋盘问题解的概率。</p><h3 id="马踏棋盘问题中度数最小的位置是否一定是下一步移动的最佳选择">马踏棋盘问题中，度数最小的位置是否一定是下一步移动的最佳选择？</h3><p>在马踏棋盘问题中，度数最小的位置不一定是下一步移动的最佳选择。尽管选择度数最小的位置有助于保持马的移动范围广阔，但并不能保证一定能找到问题的解。</p><p>马踏棋盘问题是一个非常复杂的组合问题，具有高度的分支因子和状态空间。在某些情况下，选择度数最小的位置可能导致陷入局部最优解，从而无法找到全局最优解，或者根本找不到解。</p><p>在某些特定的起始位置和棋盘大小下，可能存在一些特殊的路径或遍历顺序，使得度数最小的位置并不是最佳的选择。因此，仅凭度数最小来确定下一步移动的位置并不能保证找到最佳解。</p><p>为了提高找到最佳解的概率，通常需要采用更加复杂的算法和启发式策略，例如回溯算法、深度优先搜索、广度优先搜索、剪枝等。这些算法可以考虑更多的因素，如节点的可达性、棋盘上的局部结构、路径的延伸性等，以更有效地搜索解空间并找到更优的解。</p><p>因此，在解决马踏棋盘问题时，度数最小的位置可以作为一种启发式指导，但不能保证一定是下一步移动的最佳选择，需要结合其他算法和策略来综合评估和确定下一步的移动位置。</p><h2 id="python代码">python代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>lines = sys.stdin.readlines()<br><br><span class="hljs-comment"># 删除换行符并转换为整数</span><br>lines = np.array([<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, line.strip().split())) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines])<br><br><span class="hljs-comment"># lines是一个矩阵，每个点的值代表该点的访问顺序</span><br><span class="hljs-comment"># 例如，lines[0][0] = 1，代表第一个访问的点是(0, 0)</span><br><span class="hljs-comment"># lines[0][1] = 34，代表第三十四个访问的点是(0, 1)</span><br><span class="hljs-comment"># lines[1][0] = 4，代表第四个访问的点是(1, 0)</span><br><br>order_x = []<br>order_y = []<br><br>count = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> count &lt;= <span class="hljs-built_in">len</span>(lines)**<span class="hljs-number">2</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lines)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lines)):<br>            <span class="hljs-keyword">if</span> lines[i][j] == count:<br>                order_x.append(i)<br>                order_y.append(j)<br>                count += <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 绘制棋盘</span><br>plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))<br><br><span class="hljs-comment"># 绘制棋盘的格子</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lines)+<span class="hljs-number">1</span>):<br>    plt.plot([i, i], [<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(lines)], color=<span class="hljs-string">&#x27;black&#x27;</span>)<br>    plt.plot([<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(lines)], [i, i], color=<span class="hljs-string">&#x27;black&#x27;</span>)<br><br>count = <span class="hljs-number">1</span><br><span class="hljs-comment"># 绘制马的行走路线</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(order_x)-<span class="hljs-number">1</span>):<br>    plt.plot([order_x[i]+<span class="hljs-number">0.5</span>, order_x[i+<span class="hljs-number">1</span>]+<span class="hljs-number">0.5</span>], [order_y[i]+<span class="hljs-number">0.5</span>, order_y[i+<span class="hljs-number">1</span>]+<span class="hljs-number">0.5</span>], color=<span class="hljs-string">&#x27;red&#x27;</span>, )<br>    plt.scatter(order_x[i]+<span class="hljs-number">0.5</span>, order_y[i]+<span class="hljs-number">0.5</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>)<br>    <span class="hljs-comment"># 加上序号</span><br>    plt.text(order_x[i]+<span class="hljs-number">0.5</span>, order_y[i]+<span class="hljs-number">0.5</span>, <span class="hljs-built_in">str</span>(count), fontsize=<span class="hljs-number">12</span>)<br>    count += <span class="hljs-number">1</span><br>    plt.pause(<span class="hljs-number">0.01</span>)<br>    <br><span class="hljs-comment"># 绘制最后一个点</span><br>plt.scatter(order_x[-<span class="hljs-number">1</span>]+<span class="hljs-number">0.5</span>, order_y[-<span class="hljs-number">1</span>]+<span class="hljs-number">0.5</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>)<br>plt.text(order_x[-<span class="hljs-number">1</span>]+<span class="hljs-number">0.6</span>, order_y[-<span class="hljs-number">1</span>]+<span class="hljs-number">0.6</span>, <span class="hljs-built_in">str</span>(count), fontsize=<span class="hljs-number">12</span>)<br>plt.show()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c代码&quot;&gt;c代码&lt;/h2&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp</summary>
      
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
  </entry>
  
  <entry>
    <title>cloudlflare推理llama2</title>
    <link href="https://studyinglover.com/2023/10/11/cloudlflare%E6%8E%A8%E7%90%86llama2/"/>
    <id>https://studyinglover.com/2023/10/11/cloudlflare%E6%8E%A8%E7%90%86llama2/</id>
    <published>2023-10-11T15:32:00.000Z</published>
    <updated>2024-02-03T15:39:26.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cloudlflare推理llama2">cloudlflare推理llama2</h1><p>最近，cloudlfare悄悄上线了一项新功能，全球网络上的gpu加速推理，显然的，我们可以用它推理llama2,cloudflare也提供了一个库进行推理。</p><p>新建一个cloudflare,然后，代码改成下面的，就可以进行推理了 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Ai</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./vendor/@cloudflare/ai.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">request, env</span>) &#123;<br>    <span class="hljs-keyword">const</span> tasks = [];<br>    <span class="hljs-keyword">const</span> ai = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ai</span>(env.<span class="hljs-property">AI</span>);<br><br>    <span class="hljs-comment">// Get the request body</span><br>    <span class="hljs-keyword">const</span> requestBody = <span class="hljs-keyword">await</span> request.<span class="hljs-title function_">json</span>();<br><br>    <span class="hljs-comment">// messages - chat style input</span><br>    <span class="hljs-keyword">let</span> chat = &#123;<br>      <span class="hljs-attr">messages</span>: [<br>        &#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;You are a helpful, kind, honest, friendly, good at writing and never fails to answer my requests immediately and with details and precision.&#x27;</span>&#125;,<br>        &#123; <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">content</span>: requestBody.<span class="hljs-property">prompt</span> &#125;<br>      ]<br>    &#125;;<br>    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> ai.<span class="hljs-title function_">run</span>(<span class="hljs-string">&#x27;@cf/meta/llama-2-7b-chat-int8&#x27;</span>, chat);<br>    tasks.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">inputs</span>: chat, response &#125;);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">json</span>(tasks);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>我们可以测试一下,在命令行运行下面的命令，将<code>https://example.workers.dev/</code> 换成你的网址。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -X POST https://example.workers.dev/ -d <span class="hljs-string">&#x27;&#123;&quot;prompt&quot;:&quot;Write a poem that talks about the connectivity cloud&quot;&#125;&#x27;</span> <br></code></pre></td></tr></table></figure></p><p>看到类似下面的返回值代表成功 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">[&#123;<span class="hljs-string">&quot;inputs&quot;</span>:&#123;<span class="hljs-string">&quot;messages&quot;</span>:[&#123;<span class="hljs-string">&quot;role&quot;</span>:<span class="hljs-string">&quot;system&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;You are a helpful, kind, honest, friendly, good at writing and never fails to answer my requests immediately and with details and precision.&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;role&quot;</span>:<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;Write a poem that talks about the connectivity cloud&quot;</span>&#125;]&#125;,<span class="hljs-string">&quot;response&quot;</span>:&#123;<span class="hljs-string">&quot;response&quot;</span>:<span class="hljs-string">&quot;In the realm of the digital sky,<span class="hljs-subst">\n</span>Where information flows, and data fly,<span class="hljs-subst">\n</span>There&#x27;s a place that brings us all together,<span class="hljs-subst">\n</span>A connectivity cloud, a true forever.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>It&#x27;s a space that&#x27;s vast and wide,<span class="hljs-subst">\n</span>Where thoughts and ideas collide,<span class="hljs-subst">\n</span>A hub of communication and exchange,<span class="hljs-subst">\n</span>Where the world&#x27;s voices all combine and blend.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>In this cloud of connectivity,<span class="hljs-subst">\n</span>We find our voices, our identity,<span class="hljs-subst">\n</span>A platform for sharing and growth,<span class="hljs-subst">\n</span>Where our stories are told and our dreams take flight.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>With just a click or tap of a key,<span class="hljs-subst">\n</span>We can connect with anyone, anywhere,<span class="hljs-subst">\n</span>Sharing laughter, love, and tears,<span class="hljs-subst">\n</span>In this digital embrace, we all share.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>So let us cherish this cloud of connectivity,<span class="hljs-subst">\n</span>This gift that brings us all sovereignty,<span class="hljs-subst">\n</span>For in its depths, we find our tribe,<span class="hljs-subst">\n</span>And our voices, heard, can never be denied.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>In this cloud of connectivity,<span class="hljs-subst">\n</span>We are all connected, you see,<span class="hljs-subst">\n</span>A global community, united and free,<span class="hljs-subst">\n</span>In this digital age, where we all can be&quot;</span>&#125;&#125;]<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cloudlflare推理llama2&quot;&gt;cloudlflare推理llama2&lt;/h1&gt;
&lt;p&gt;最近，cloudlfare悄悄上线了一项新功能，全球网络上的gpu加速推理，显然的，我们可以用它推理llama2,cloudflare也提供了一个库进行推理。&lt;/p&gt;</summary>
      
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
  </entry>
  
  <entry>
    <title>docker搭建elasticsearch并使用python连接</title>
    <link href="https://studyinglover.com/2023/10/09/docker%E6%90%AD%E5%BB%BAelasticsearch%E5%B9%B6%E4%BD%BF%E7%94%A8python%E8%BF%9E%E6%8E%A5/"/>
    <id>https://studyinglover.com/2023/10/09/docker%E6%90%AD%E5%BB%BAelasticsearch%E5%B9%B6%E4%BD%BF%E7%94%A8python%E8%BF%9E%E6%8E%A5/</id>
    <published>2023-10-09T21:48:00.000Z</published>
    <updated>2024-02-03T15:39:26.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker搭建elasticsearch并使用python连接">docker搭建elasticsearch并使用python连接</h1><h2 id="搭建">搭建</h2><p>创建一个docker网络 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create elastic<br></code></pre></td></tr></table></figure></p><p>然后拉elasticsearch 的docker 容器 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull docker.elastic.co/elasticsearch/elasticsearch:8.10.2<br></code></pre></td></tr></table></figure></p><p>运行容器 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name es01 --net elastic -p 9200:9200 -it -m 1GB docker.elastic.co/elasticsearch/elasticsearch:8.10.2<br></code></pre></td></tr></table></figure></p><p>如果遇到报错<code>Elasticsearch exited unexpectedly, with exit code 78</code> ，在终端运行<code>sudo sysctl -w vm.max_map_count=262144</code>然后删掉刚才的镜像，重新运行容器。(这个设置重启后会失效，可以在<code>/etc/sysctl.conf</code>以设置使其永久有效。)</p><p>成功运行终端会弹出很多信息，然后最后会给出密码等，如下</p><p><img src="https://cdn.studyinglover.com/pic/2023/10/415a20e102e85b136bc5831f789a10af.png" /></p><p>记得保存密码，可以将密码加到环境变量里<code>export ELASTIC_PASSWORD="your_password"</code>，他只会弹出一次。如果忘了也可以重置密码 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it es01 /usr/share/elasticsearch/bin/elasticsearch-reset-password -u elastic<br>docker <span class="hljs-built_in">exec</span> -it es01 /usr/share/elasticsearch/bin/elasticsearch-create-enrollment-token -s kibana<br></code></pre></td></tr></table></figure></p><h2 id="验证是否正常运行">验证是否正常运行</h2><p>把证书从容器中复制一份 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> es01:/usr/share/elasticsearch/config/certs/http_ca.crt .<br></code></pre></td></tr></table></figure></p><p>然后运行命令查看restful api是否正常运行 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">curl <span class="hljs-attr">--cacert</span> http_ca<span class="hljs-selector-class">.crt</span> -u elastic:<span class="hljs-variable">$ELASTIC_PASSWORD</span> https:<span class="hljs-comment">//localhost:9200</span><br></code></pre></td></tr></table></figure> 如果看到类似下图的信息就成功了 <img src="https://cdn.studyinglover.com/pic/2023/10/fa51ee2db2826abe7649dc0b88865beb.png" alt="image.png" /></p><h2 id="python连接">python连接</h2><p>运行下面的代码,password改成你自己的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> elasticsearch <span class="hljs-keyword">import</span> AsyncElasticsearch<br><span class="hljs-keyword">import</span> ssl<br><span class="hljs-keyword">import</span> asyncio<br><br>ssl_context = ssl.create_default_context(cafile=<span class="hljs-string">&#x27;info/http_ca.crt&#x27;</span>)<br>es = AsyncElasticsearch(<br>    [<span class="hljs-string">&#x27;https://localhost:9200&#x27;</span>],<br>    http_auth=(<span class="hljs-string">&#x27;elastic&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>),<br>    scheme=<span class="hljs-string">&quot;https&quot;</span>,<br>    ssl_context=ssl_context<br>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    info = <span class="hljs-keyword">await</span> es.info()<br>    <span class="hljs-built_in">print</span>(info)<br>    <span class="hljs-keyword">await</span> es.close()<br><br><span class="hljs-comment"># 运行主函数</span><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p>看到类似下面的输出代表运行成功 <img src="https://cdn.studyinglover.com/pic/2023/10/2c951211fd5820abebf0395b779f35bd.png" alt="image.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker搭建elasticsearch并使用python连接&quot;&gt;docker搭建elasticsearch并使用python连接&lt;/h1&gt;
&lt;h2 id=&quot;搭建&quot;&gt;搭建&lt;/h2&gt;
&lt;p&gt;创建一个docker网络 &lt;figure class=&quot;highlight</summary>
      
    
    
    
    <category term="踩坑" scheme="https://studyinglover.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
  </entry>
  
</feed>
