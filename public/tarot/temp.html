<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ²‰æµ¸å¼å¡”ç½— - å‘½è¿ä¹‹æ‰‹</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: "Songti SC", "SimSun", "STSong", serif; user-select: none; }
        
        /* UI å®¹å™¨ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        /* é¡¶éƒ¨çŠ¶æ€æ  */
        #top-bar {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: #d4af37; letter-spacing: 4px; text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            font-size: 24px; font-weight: bold;
        }
        #gesture-hint { font-size: 16px; color: #aaa; margin-top: 8px; opacity: 0.8; letter-spacing: 1px; font-weight: normal;}
        
        /* å¡ç‰Œè¯¦æƒ…å±•ç¤º (åº•éƒ¨ä¸­å¤®) */
        #active-card-info {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            text-align: center; opacity: 0; transition: opacity 0.3s;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            padding: 20px 40px; border-radius: 10px; width: 70%; max-width: 600px;
        }
        #card-title { font-size: 36px; color: #fff; margin-bottom: 8px; text-shadow: 0 2px 4px #000; }
        #card-meaning { font-size: 18px; color: #ddd; line-height: 1.6; text-shadow: 0 1px 2px #000; }
        
        .reversed-flag { 
            color: #ff5555; font-size: 0.5em; border: 1px solid #ff5555; 
            padding: 2px 6px; border-radius: 4px; vertical-align: middle; margin-left: 10px; 
            letter-spacing: 1px;
        }

        /* å·¦ä¸‹è§’å†å²è®°å½• */
        #history-dock {
            position: absolute; bottom: 20px; left: 20px; width: 80px; 
            display: flex; flex-direction: column-reverse; gap: 10px;
            pointer-events: auto;
        }
        .history-thumb {
            width: 60px; height: 90px; border: 1px solid #444; border-radius: 4px;
            background-size: cover; background-position: center;
            opacity: 0.7; transition: all 0.3s; box-shadow: 0 0 5px #000;
        }
        .history-thumb:hover { opacity: 1; transform: scale(1.5) translateX(20px); z-index: 100; border-color: #d4af37; }

        /* å³ä¸Šè§’æ§åˆ¶åŒº */
        #controls { position: absolute; top: 20px; right: 20px; pointer-events: auto; }
        button {
            background: rgba(20, 20, 20, 0.8); color: #d4af37; border: 1px solid #666;
            padding: 8px 16px; cursor: pointer; transition: 0.3s; 
            font-family: "Songti SC", serif; font-size: 16px;
        }
        button:hover { border-color: #d4af37; background: #333; color: #fff; }

        /* æ‘„åƒå¤´é¢„è§ˆ */
        #cam-preview {
            position: absolute; bottom: 10px; right: 10px; width: 140px; 
            border: 1px solid #333; opacity: 0.3; transform: scaleX(-1); border-radius: 4px;
        }

        /* åŠ è½½æç¤º */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            color: #d4af37; text-align: center; font-size: 20px; pointer-events: auto;
            background: #111; padding: 40px; border: 1px solid #444; box-shadow: 0 0 20px #000;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">æ­£åœ¨è¿æ¥çµç•Œ...<br><span style="font-size:14px;color:#888">è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥å¼€å¯æ‰‹åŠ¿å åœ</span></div>

    <div id="ui-layer">
        <div id="top-bar">
            <div>å‘½ è¿ ä¹‹ è½®</div>
            <div id="gesture-hint">æ­£åœ¨å¯»æ‰¾æ‰‹åŠ¿ä¿¡å·...</div>
        </div>

        <div id="active-card-info">
            <div id="card-title"></div>
            <div id="card-meaning"></div>
        </div>

        <div id="history-dock"></div>

        <div id="controls">
            <button onclick="resetSpread()">é‡æ´—ç‰Œé˜µ</button>
            <button id="mode-btn" onclick="toggleMode()">æ¨¡å¼: æ‰‹åŠ¿</button>
        </div>

        <video id="cam-preview" playsinline></video>
    </div>

<script>
/**
 * ğŸ› ï¸ æ ¸å¿ƒé…ç½®åŒºåŸŸ
 */
const CONFIG = {
    cardCount: 5,        // æ¡Œé¢æ˜¾ç¤ºå‡ å¼ ç‰Œ
    spacing: 2.2,        // é—´è·
    cardW: 2.0,          // å®½
    cardH: 3.5,          // é«˜
    cameraZ: 10,         
    pinchThresh: 0.08,   
    fistThresh: 0.12     
};

// å›¾ç‰‡è·¯å¾„é…ç½®
const PATHS = {
    back: "./img/back.png",
    getFront: (filename) => `./img/${filename}`
};

// -------------------------------------------------------------
// ğŸƒ 78 å¼ å¡”ç½—ç‰Œæ±‰åŒ–æ•°æ®åº“
// -------------------------------------------------------------

// 1. åŸºç¡€è¯å…¸
const SUITS_CN = { w: 'æƒæ–', c: 'åœ£æ¯', s: 'å®å‰‘', p: 'æ˜Ÿå¸' };
const NUMBERS_CN = { 
    '01':'ä¸€', '02':'äºŒ', '03':'ä¸‰', '04':'å››', '05':'äº”', 
    '06':'å…­', '07':'ä¸ƒ', '08':'å…«', '09':'ä¹', '10':'å', 
    '11':'ä¾ä»', '12':'éª‘å£«', '13':'ç‹å', '14':'å›½ç‹' 
};

// 2. ç‰Œä¹‰åº“ (å¤§é˜¿å¡çº³ + å››å…ƒç´ ç®€è¿°)
const MEANINGS_CN = {
    // å¤§é˜¿å¡çº³
    'm00': 'æ–°çš„å¼€å§‹ã€å¤©çœŸã€è‡ªç”±ç²¾ç¥ã€å†’é™©ã€‚', 
    'm01': 'åˆ›é€ åŠ›ã€æ„å¿—åŠ›ã€æ˜¾åŒ–ã€è‡ªä¿¡ã€‚',
    'm02': 'ç›´è§‰ã€æ½œæ„è¯†ã€å†…åœ¨æ™ºæ…§ã€ç¥ç§˜ã€‚', 
    'm03': 'ä¸°é¥¶ã€æ¯æ€§ã€è‡ªç„¶ã€æ„Ÿå®˜äº«å—ã€‚',
    'm04': 'æƒå¨ã€ç»“æ„ã€æ§åˆ¶ã€çˆ¶äº²å½¢è±¡ã€‚', 
    'm05': 'ä¼ ç»Ÿã€ä¿¡ä»°ã€æ•™å¯¼ã€å¢¨å®ˆæˆè§„ã€‚',
    'm06': 'çˆ±ã€ç»“åˆã€é€‰æ‹©ã€ä»·å€¼è§‚çš„å’Œè°ã€‚', 
    'm07': 'æ„å¿—ã€èƒœåˆ©ã€æ§åˆ¶ã€é€šè¿‡è¡ŒåŠ¨å…‹æœéšœç¢ã€‚',
    'm08': 'å†…åœ¨åŠ›é‡ã€å‹‡æ°”ã€è€å¿ƒã€åŒæƒ…å¿ƒã€‚', 
    'm09': 'å†…çœã€ç‹¬å¤„ã€å¯»æ±‚çœŸç†ã€æŒ‡å¼•ã€‚',
    'm10': 'å‘½è¿ã€è½¬æŠ˜ç‚¹ã€å› æœå¾ªç¯ã€ä¸å¯æŠ—åŠ›ã€‚', 
    'm11': 'æ­£ä¹‰ã€å…¬å¹³ã€çœŸç†ã€å› æœè´£ä»»ã€‚',
    'm12': 'ç‰ºç‰²ã€æ¢ä¸ªè§’åº¦ã€æ”¾ä¸‹ã€ç­‰å¾…ã€‚', 
    'm13': 'ç»“æŸã€è½¬åŒ–ã€é‡ç”Ÿã€å¿…ç„¶çš„æ”¹å˜ã€‚',
    'm14': 'å¹³è¡¡ã€èŠ‚åˆ¶ã€è€å¿ƒã€è°ƒå’Œã€‚', 
    'm15': 'æŸç¼šã€ç‰©è´¨ä¸»ä¹‰ã€æ¬²æœ›ã€é˜´æš—é¢ã€‚',
    'm16': 'çªå˜ã€ç¾éš¾ã€å¯ç¤ºã€æ—§ç»“æ„çš„å´©å¡Œã€‚', 
    'm17': 'å¸Œæœ›ã€çµæ„Ÿã€æ²»æ„ˆã€å®é™ã€‚',
    'm18': 'å¹»è§‰ã€ä¸å®‰ã€æ½œæ„è¯†ã€ç›´è§‰ã€‚', 
    'm19': 'æˆåŠŸã€å¿«ä¹ã€æ´»åŠ›ã€æ¸…æ™°ã€‚',
    'm20': 'å®¡åˆ¤ã€è§‰é†’ã€é‡ç”Ÿã€æ„Ÿå¬ã€‚', 
    'm21': 'åœ†æ»¡ã€è¾¾æˆã€æ—…è¡Œã€æ–°çš„å‘¨æœŸã€‚',
    
    // å°é˜¿å¡çº³é€šç”¨è¯æ ¹ (å¦‚æœæ‰¾ä¸åˆ°å…·ä½“IDï¼Œç”¨è¿™ä¸ªç”Ÿæˆ)
    'w': 'è¡ŒåŠ¨ã€æ¿€æƒ…ä¸åˆ›é€ åŠ›çš„èƒ½é‡ã€‚',
    'c': 'æƒ…æ„Ÿã€å…³ç³»ä¸æ½œæ„è¯†çš„æµåŠ¨ã€‚',
    's': 'ç†æ™ºã€æ€æƒ³ä¸å†²çªçš„é”‹èŠ’ã€‚',
    'p': 'ç‰©è´¨ã€å·¥ä½œä¸ç°å®çš„æˆæœã€‚'
};

const TAROT_DB = [];

// ç”Ÿæˆå¤§é˜¿å¡çº³ (Major Arcana)
const MAJORS_CN = [
    "æ„šäºº", "é­”æœ¯å¸ˆ", "å¥³ç¥­å¸", "çš‡å", "çš‡å¸", 
    "æ•™çš‡", "æ‹äºº", "æˆ˜è½¦", "åŠ›é‡", "éšå£«", 
    "å‘½è¿ä¹‹è½®", "æ­£ä¹‰", "å€’åŠäºº", "æ­»ç¥", "èŠ‚åˆ¶", 
    "æ¶é­”", "é«˜å¡”", "æ˜Ÿæ˜Ÿ", "æœˆäº®", "å¤ªé˜³", "å®¡åˆ¤", "ä¸–ç•Œ"
];

for(let i=0; i<=21; i++) {
    let code = 'm' + (i<10?'0'+i:i);
    TAROT_DB.push({
        id: code,
        name: MAJORS_CN[i], // ä¸­æ–‡å
        img: code + '.jpg',
        meaning: MEANINGS_CN[code] || "å¤§é˜¿å¡çº³çš„å¥¥ç§˜ã€‚"
    });
}

// ç”Ÿæˆå°é˜¿å¡çº³ (Minor Arcana)
['w','c','s','p'].forEach(suitCode => {
    for(let i=1; i<=14; i++) {
        let numCode = i<10 ? '0'+i : ''+i;
        let fileCode = suitCode + numCode;
        
        // ç»„åˆä¸­æ–‡åï¼šä¾‹å¦‚ "æƒæ–å›½ç‹" æˆ– "åœ£æ¯ä¸‰"
        // ä¹ æƒ¯ä¸Šï¼šäººç‰©ç‰Œæ˜¯ "æƒæ–å›½ç‹"ï¼Œæ•°å­—ç‰Œæ˜¯ "æƒæ–ä¸‰"
        let nameCN = SUITS_CN[suitCode] + NUMBERS_CN[numCode];
        
        // ç®€å•ç”Ÿæˆå«ä¹‰
        let mean = "";
        if(i === 1) mean = `${SUITS_CN[suitCode]}èƒ½é‡çš„èŒèŠ½ä¸æ–°æœºä¼šã€‚`;
        else if(i === 14) mean = `å¯¹${SUITS_CN[suitCode]}é¢†åŸŸçš„æŒæ§ä¸æˆç†Ÿã€‚`;
        else mean = `${SUITS_CN[suitCode]}å±‚é¢çš„ç»å†ä¸è¯¾é¢˜ã€‚`;
        
        TAROT_DB.push({
            id: fileCode,
            name: nameCN,
            img: fileCode + '.jpg',
            meaning: mean
        });
    }
});

// -------------------------------------------------------------

// --- å…¨å±€çŠ¶æ€ ---
let state = {
    mode: 'hand',
    handPos: new THREE.Vector2(0,0),
    gesture: 'OPEN',
    cards: [],
    grabbedCard: null,
    isRevealed: false
};

// --- Three.js å˜é‡ ---
let scene, camera, renderer, raycaster;
let handCursor;
let particleSystem;

// ==========================================
// ğŸš€ åˆå§‹åŒ–
// ==========================================
async function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020202);
    scene.fog = new THREE.FogExp2(0x020202, 0.02);

    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 12);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const ambient = new THREE.AmbientLight(0xffffff, 0.4); 
    scene.add(ambient);
    
    const spot = new THREE.SpotLight(0xffeebb, 1.5);
    spot.position.set(0, 10, 5);
    spot.angle = 0.6;
    spot.penumbra = 0.5;
    spot.castShadow = true;
    scene.add(spot);

    const cursorGeo = new THREE.SphereGeometry(0.1, 16, 16);
    const cursorMat = new THREE.MeshBasicMaterial({ color: 0xffffaa, transparent: true, opacity: 0.6 });
    handCursor = new THREE.Mesh(cursorGeo, cursorMat);
    scene.add(handCursor);

    raycaster = new THREE.Raycaster();

    spawnSpread();
    setupCamera();

    window.addEventListener('resize', onResize);
    setupMouseFallback();
    
    animate();
}

// ==========================================
// ğŸƒ å¡ç‰Œé€»è¾‘
// ==========================================
function spawnSpread() {
    state.cards.forEach(c => scene.remove(c.mesh));
    state.cards = [];
    if (state.grabbedCard) { scene.remove(state.grabbedCard.mesh); state.grabbedCard = null; }
    document.getElementById('active-card-info').style.opacity = 0;

    const texLoader = new THREE.TextureLoader();
    const geo = new THREE.BoxGeometry(CONFIG.cardW, CONFIG.cardH, 0.05);

    const totalW = (CONFIG.cardCount - 1) * CONFIG.spacing;
    const startX = -totalW / 2;

    for (let i = 0; i < CONFIG.cardCount; i++) {
        const data = TAROT_DB[Math.floor(Math.random() * TAROT_DB.length)];
        const isReversed = Math.random() < 0.5;

        const matBack = new THREE.MeshStandardMaterial({ 
            map: texLoader.load(PATHS.back), 
            color: 0xffffff,
            roughness: 0.7
        });
        
        const frontUrl = PATHS.getFront(data.img);
        const matFront = new THREE.MeshStandardMaterial({
            map: texLoader.load(frontUrl, undefined, undefined, (e) => {
                console.warn("Image missing:", frontUrl);
            }),
            color: 0xffffff,
            roughness: 0.4
        });
        const matSide = new THREE.MeshStandardMaterial({ color: 0x111111 });

        const mesh = new THREE.Mesh(geo, [matSide, matSide, matSide, matSide, matFront, matBack]);
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        const x = startX + i * CONFIG.spacing;
        mesh.position.set(x, -1, 0); 
        mesh.rotation.y = Math.PI; 
        
        const cardObj = {
            mesh: mesh,
            data: data,
            isReversed: isReversed,
            originalPos: new THREE.Vector3(x, -1, 0),
            id: i
        };
        
        scene.add(mesh);
        state.cards.push(cardObj);
    }
}

// ==========================================
// ğŸ® äº¤äº’æ ¸å¿ƒ
// ==========================================
function updateInteraction() {
    const vec = new THREE.Vector3(state.handPos.x, state.handPos.y, 0.5);
    vec.unproject(camera);
    const dir = vec.sub(camera.position).normalize();
    const targetCursorPos = camera.position.clone().add(dir.multiplyScalar(10)); 
    handCursor.position.lerp(targetCursorPos, 0.2);

    const hint = document.getElementById('gesture-hint');
    if (state.mode === 'hand') {
        let cnGesture = "ç­‰å¾…æ‰‹åŠ¿...";
        if(state.gesture === 'OPEN') cnGesture = "æ‰‹æŒå¼ å¼€ (ç§»åŠ¨)";
        if(state.gesture === 'PINCH') cnGesture = "æåˆ (æŠ“å–)";
        if(state.gesture === 'FIST') cnGesture = "æ¡æ‹³ (ç¡®è®¤)";
        
        hint.innerText = `å½“å‰æ‰‹åŠ¿: ${cnGesture}`;
        handCursor.material.color.setHex(state.gesture === 'PINCH' ? 0x00ff00 : (state.gesture === 'FIST' ? 0xff0000 : 0xffffaa));
    } else {
        hint.innerText = `é¼ æ ‡æ¨¡å¼: ç‚¹å‡»æ‹–æ‹½æŠ“å–ï¼Œç©ºæ ¼é”®ç¡®è®¤`;
    }

    if (state.grabbedCard) {
        const card = state.grabbedCard;

        if (state.gesture === 'OPEN') {
            returnCardToTable(card);
            state.grabbedCard = null;
        } 
        else if (state.gesture === 'FIST') {
            confirmAndBurn(card);
            state.grabbedCard = null;
        } 
        else {
            const holdPos = handCursor.position.clone();
            holdPos.z = 6; 
            holdPos.y -= 0.5;
            card.mesh.position.lerp(holdPos, 0.15); 
            card.mesh.rotation.x = (state.handPos.y * 0.5); 
            
            const targetRotY = 0; 
            const targetRotZ = card.isReversed ? Math.PI : 0;
            card.mesh.rotation.y = THREE.MathUtils.lerp(card.mesh.rotation.y, targetRotY, 0.1);
            card.mesh.rotation.z = THREE.MathUtils.lerp(card.mesh.rotation.z, targetRotZ, 0.1);

            if (!state.isRevealed && Math.abs(card.mesh.rotation.y) < 1.0) {
                state.isRevealed = true;
                showCardInfo(card);
            }
        }
    } 
    else {
        raycaster.setFromCamera(state.handPos, camera);
        const meshes = state.cards.map(c => c.mesh);
        const intersects = raycaster.intersectObjects(meshes);

        if (intersects.length > 0) {
            const hitMesh = intersects[0].object;
            const hitCard = state.cards.find(c => c.mesh === hitMesh);

            if (hitCard) {
                const hoverY = -0.5;
                hitCard.mesh.position.y = THREE.MathUtils.lerp(hitCard.mesh.position.y, hoverY, 0.2);
                
                if (state.gesture === 'PINCH') {
                    state.grabbedCard = hitCard;
                    state.isRevealed = false; 
                    state.cards = state.cards.filter(c => c !== hitCard);
                }
            }
        }

        state.cards.forEach(c => {
            if (!intersects.length || intersects[0].object !== c.mesh) {
                c.mesh.position.lerp(c.originalPos, 0.1);
                c.mesh.rotation.y = THREE.MathUtils.lerp(c.mesh.rotation.y, Math.PI, 0.1);
                c.mesh.rotation.z = THREE.MathUtils.lerp(c.mesh.rotation.z, 0, 0.1);
            }
        });
    }
}

function returnCardToTable(card) {
    state.cards.push(card);
    document.getElementById('active-card-info').style.opacity = 0;
}

function confirmAndBurn(card) {
    createAshEffect(card.mesh);
    addHistoryThumb(card);
    scene.remove(card.mesh);
    document.getElementById('active-card-info').style.opacity = 0;
}

function createAshEffect(mesh) {
    const count = 800;
    const geo = new THREE.BufferGeometry();
    const positions = [];
    const velocities = [];
    const worldPos = new THREE.Vector3();
    mesh.getWorldPosition(worldPos);

    for(let i=0; i<count; i++) {
        positions.push(
            worldPos.x + (Math.random()-0.5) * CONFIG.cardW,
            worldPos.y + (Math.random()-0.5) * CONFIG.cardH,
            worldPos.z + (Math.random()-0.5) * 0.1
        );
        velocities.push(
            (Math.random()-0.5)*0.05, 
            Math.random()*0.1 + 0.02, 
            (Math.random()-0.5)*0.05
        );
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    const mat = new THREE.PointsMaterial({ color: 0xffaa44, size: 0.08, transparent: true, blending: THREE.AdditiveBlending });
    const points = new THREE.Points(geo, mat);
    scene.add(points);
    
    let age = 0;
    const anim = () => {
        if (age > 60) { scene.remove(points); return; }
        age++;
        const pos = points.geometry.attributes.position.array;
        for(let i=0; i<count; i++) {
            pos[i*3] += velocities[i*3];
            pos[i*3+1] += velocities[i*3+1];
            pos[i*3+2] += velocities[i*3+2];
            pos[i*3] += Math.sin(age*0.1 + i)*0.005;
        }
        points.geometry.attributes.position.needsUpdate = true;
        points.material.opacity = 1 - (age/60);
        requestAnimationFrame(anim);
    };
    anim();
}

function showCardInfo(card) {
    const el = document.getElementById('active-card-info');
    const titleEl = document.getElementById('card-title');
    const meanEl = document.getElementById('card-meaning');
    
    let titleHtml = card.data.name;
    // é€†ä½æç¤º
    if (card.isReversed) {
        titleHtml += `<span class="reversed-flag">é€†ä½</span>`;
    }
    
    titleEl.innerHTML = titleHtml;
    // ç®€å•çš„å«ä¹‰æ‹¼æ¥
    let meaningText = card.data.meaning;
    if (card.isReversed) {
        meaningText = "ã€é€†ä½å«ä¹‰ã€‘" + meaningText + " (èƒ½é‡å—é˜»æˆ–å†…åŒ–)";
    }
    meanEl.innerText = meaningText;
    el.style.opacity = 1;
}

function addHistoryThumb(card) {
    const dock = document.getElementById('history-dock');
    const thumb = document.createElement('div');
    thumb.className = 'history-thumb';
    const url = PATHS.getFront(card.data.img);
    thumb.style.backgroundImage = `url('${url}')`;
    if (card.isReversed) {
        thumb.style.transform = "rotate(180deg)";
    }
    dock.appendChild(thumb);
}

function resetSpread() {
    spawnSpread();
}

async function setupCamera() {
    try {
        const video = document.getElementById('cam-preview');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });
        
        hands.onResults((results) => {
            if (state.mode !== 'hand') return;
            if (results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                state.handPos.x = (1 - lm[8].x) * 2 - 1; 
                state.handPos.y = -(lm[8].y * 2 - 1); 
                const d = (i1, i2) => { 
                    const p1 = lm[i1], p2 = lm[i2];
                    return Math.hypot(p1.x-p2.x, p1.y-p2.y);
                };
                const pinchDist = d(4, 8); 
                const wristToMiddle = d(0, 12); 
                if (wristToMiddle < CONFIG.fistThresh) state.gesture = 'FIST';
                else if (pinchDist < CONFIG.pinchThresh) state.gesture = 'PINCH';
                else state.gesture = 'OPEN';
            }
        });

        const cameraUtils = new Camera(video, {
            onFrame: async () => await hands.send({image: video}),
            width: 640, height: 480
        });
        await cameraUtils.start();
        document.getElementById('loader').style.display = 'none';
        
    } catch (e) {
        console.error(e);
        document.getElementById('loader').innerHTML = "æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè‡ªåŠ¨åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼ã€‚";
        setTimeout(() => toggleMode(), 2000);
    }
}

function setupMouseFallback() {
    document.addEventListener('mousemove', (e) => {
        if (state.mode !== 'mouse') return;
        state.handPos.x = (e.clientX / window.innerWidth) * 2 - 1;
        state.handPos.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });
    document.addEventListener('mousedown', () => { if(state.mode === 'mouse') state.gesture = 'PINCH'; });
    document.addEventListener('mouseup', () => { if(state.mode === 'mouse') state.gesture = 'OPEN'; });
    window.addEventListener('keydown', (e) => { 
        if(state.mode === 'mouse' && e.code === 'Space') state.gesture = 'FIST'; 
    });
    window.addEventListener('keyup', (e) => { 
        if(state.mode === 'mouse' && e.code === 'Space') state.gesture = 'PINCH'; 
    });
}

function toggleMode() {
    state.mode = state.mode === 'hand' ? 'mouse' : 'hand';
    document.getElementById('mode-btn').innerText = "æ¨¡å¼: " + (state.mode === 'hand' ? "æ‰‹åŠ¿" : "é¼ æ ‡");
    document.getElementById('cam-preview').style.display = state.mode === 'hand' ? 'block' : 'none';
    state.gesture = 'OPEN';
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    updateInteraction();
    renderer.render(scene, camera);
}

init();

</script>
</body>
</html>